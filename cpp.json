{
	"Headers": {
		"prefix": "headers",
		"body": [
			"/** Copyright (c) 2024 huanhuanonly. All rights reserved.",
			" * ",
			" * @file  ${TM_FILENAME_BASE}",
			" * ",
			" * @brief $1",
			" * ",
			" * Created by Yanghuanhuan (huanhuanonly@gmail.com) on ${CURRENT_DAY_NAME}, ${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]",
			" */",
			"",
			"$0"
		],
		"description": "Headers"
	},

	"Headle for problem": {
		"prefix": "problem_headle",
		"body": [
			"/**",
			" * ${1:ContestTitle}",
			" * ",
			" * => ${2:Problem}",
			" * ",
			" * -> ${3:Link}",
			" * ",
			" * @b ${4:Algorithm}",
			"*/",
			"",
			"$0"
		],
		"description": "Headle for problem"
	},

	"Contest Template for C++": {
		"prefix": "contest",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using int8 = signed char;",
			"using int16 = short;",
			"using int32 = int;",
			"using int64 = long long;",
			"",
			"using uint8 = unsigned char;",
			"using uint16 = unsigned short;",
			"using uint32 = unsigned int;",
			"using uint64 = unsigned long long;",
			"",
			"#ifdef __GNUC__",
			"using int128 = __int128;",
			"using uint128 = unsigned __int128;",
			"#endif",
			"",
			"using real32 = float;",
			"using real64 = double;",
			"using real128 = long double;",
			"",
			"int main(void)",
			"{",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(nullptr), std::cout.tie(nullptr);",
			"",
			"    $0",
			"",
			"    return 0;",
			"}"
		],
		"description": "Contest Template for C++"
	},

	"IO stream redirection template": {
		"prefix": "fre",
		"body": [
			"#ifdef __localhost",
			"    ::freopen(\"in\", \"r\", stdin);",
			"    ::freopen(\"out\", \"w\", stdout);",
			"#endif"
		],
		"description": "IO stream redirection template"
	},

	"Range from first to last": {
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()"
		],
		"description": "Range from first to last"
	},

	"The is_prime() function": {
		"prefix": "is_prime",
		"body": [
			"template<typename T>",
			"bool is_prime(T n)",
			"{",
			"    if (n <= 3) return n > 1;",
			"",
			"    if (n % 6 != 1 && n % 6 != 5) return false;",
			"",
			"    for (int i = 5; i <= std::sqrt(n); i += 6)",
			"    {",
			"        if (n % i == 0 || n % (i + 2) == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "The is_prime() function"
	},

	"The get_primeset() function": {
		"prefix": "get_primeset",
		"body": [
			"template<typename T>",
			"std::vector<T> get_primeset(T n)",
			"{",
			"    std::vector<T> result;",
			"    std::vector<bool> vis(n + 1);",
			"",
			"    vis[0] = vis[1] = true;",
			"",
			"    for (int i = 2; i <= n; ++i)",
			"    {",
			"        if (vis[i] == false)",
			"            result.push_back(i);",
			"",
			"        for (int j = 0; j < result.size(); ++j)",
			"        {",
			"            if (i * result[j] > n) break;",
			"            vis[i * result[j]] = true;",
			"            if (i % result[j] == 0) break;",
			"        }",
			"    }",
			"    return result;",
			"}"
		],
		"description": "The get_primeset() function"
	},

	"The quick_mul() function": {
		"prefix": "quick_mul",
		"body": [
			"ullong quick_mul(ullong a, ullong b, ullong mod)",
			"{",
			"    a %= mod;",
			"    b %= mod;",
			"",
			"    ullong ans = 0;",
			"    while (b > 0)",
			"    {",
			"        if (b & 1) ans = (ans + a) % mod;",
			"        a = (a + a) % mod;",
			"        b >>= 1;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "The quick_mul() function"
	},

	"The quick_power() function": {
		"prefix": "quick_power",
		"body": [
			"ullong quick_power(ullong a, ullong b, ullong mod)",
			"{",
			"    a %= mod;",
			"",
			"    ullong ans = 1;",
			"    while (b)",
			"    {",
			"        if (b & 1) ans = (ans * a) % mod;",
			"        a = (a * a) % mod;",
			"        b >>= 1;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "The quick_power() function"
	},

	"The prime_factorization() function": {
		"prefix": "prime_factorization",
		"body": [
			"template<typename T>",
			"std::vector<T> prime_factorization(T __n)",
			"{",
			"    std::vector<T> res;",
			"",
			"    for (int i = 2; i <= __n / i; ++i)",
			"    {",
			"        while (__n % i == 0)",
			"        {",
			"            res.push_back(i);",
			"            __n /= i;",
			"        }",
			"    }",
			"",
			"    if (__n != 1)",
			"        res.push_back(__n);",
			"",
			"    return res;",
			"}"
		],
		"description": "The prime_factorization() function"
	},

	"The manacher() function": {
		"prefix": "manacher",
		"body": [
			"int manacher(const std::string& str)",
			"{",
			"    std::string s(1, '^');",
			"    s.reserve(str.size() * 2 + 3);",
			"    ",
			"    for (int i = 0; i < str.size(); ++i)",
			"    {",
			"        s.push_back(' ');",
			"        s.push_back(str[i]);",
			"    }",
			"",
			"    s.push_back(' ');",
			"    s.push_back('$');",
			"",
			"    int c = 0, r = 0;",
			"",
			"    std::vector<int> dp(s.size());",
			"",
			"    int ans = 0;",
			"",
			"    for (int i = 1; i < s.size() - 1; ++i)",
			"    {",
			"        if (r >= i)",
			"            dp[i] = std::min(r - i, dp[c - (i - c)]);",
			"",
			"        while (s[i - dp[i] - 1] == s[i + dp[i] + 1])",
			"            ++dp[i];",
			"",
			"        if (dp[i] + i > r)",
			"        {",
			"            r = dp[i] + i;",
			"            c = i;",
			"        }",
			"",
			"        ans = std::max(ans, dp[i]);",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "The manacher() function"
	},

	"The get_z() function": {
		"prefix": "get_z",
		"body": [
			"std::vector<int> get_z(const std::string_view& s)",
			"{",
			"    std::vector<int> z(s.size());",
			"    ",
			"    z[0] = s.size();",
			"",
			"    int l = -1, r = 0;",
			"",
			"    for (int i = 1; i < s.size(); ++i)",
			"    {",
			"        if (i <= r)",
			"            z[i] = std::min(z[i - l], r - i + 1);",
			"",
			"        while (i + z[i] < s.size() and s[z[i]] == s[i + z[i]])",
			"            ++z[i];",
			"",
			"        if (i + z[i] - 1 > r)",
			"        {",
			"            r = i + z[i] - 1;",
			"            l = i;",
			"        }",
			"    }",
			"",
			"    return z;",
			"}"
		],
		"description": "The get_z() function"
	},

	"class DisjointSet: Merge by rank": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return tree[u].fa == u ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"            tree[fv].fa = fu;",
			"        else",
			"            tree[fu].fa = fv;",
			"        ",
			"        if (tree[fu].rank == tree[fv].rank)",
			"            ++tree[fv].rank;",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Merge by rank"
	},

	"class DisjointSet: Path Compression": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    std::vector<int> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        std::iota(tree.begin(), tree.end(), 0);",
			"    }",
			"",
			"    int find(int u)",
			"    {",
			"        return tree[u] == u ? u : tree[u] = find(tree[u]);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        tree[find(v)] = find(u);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Path Compression"
	},

	"class DisjointSet: with Undo": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    std::stack<std::pair<int&, int>, std::vector<std::pair<int&, int>>> ver_fa, ver_rank;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return is_root(u) ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"        {",
			"            ver_fa.push({tree[fv].fa, tree[fv].fa});",
			"            tree[fv].fa = fu;",
			"        }",
			"        else",
			"        {",
			"            ver_fa.push({tree[fu].fa, tree[fu].fa});",
			"            tree[fu].fa = fv;",
			"        }",
			"        ",
			"        ver_rank.push({tree[fv].rank, tree[fv].rank});",
			"        if (tree[fu].rank == tree[fv].rank)",
			"        {",
			"            ++tree[fv].rank;",
			"        }",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"",
			"    void undo()",
			"    {",
			"        if (not ver_fa.empty())",
			"        {",
			"            ver_fa.top().first = ver_fa.top().second;",
			"            ver_rank.top().first = ver_rank.top().second;",
			"",
			"            ver_fa.pop();",
			"            ver_rank.pop();",
			"        }",
			"    }",
			"};"
		],
		"description": "class DisjointSet: with Undo"
	},

	"The BinaryIndexedTree template class": {
		"prefix": "BinaryIndexedTree",
		"body": [
			"// Fenwick Tree",
			"template<typename _ValueType>",
			"class BinaryIndexedTree",
			"{",
			"public:",
			"    using value_type = _ValueType;",
			"",
			"    explicit BinaryIndexedTree(std::size_t n) : arr(n) { }",
			"",
			"    static constexpr inline std::size_t lowbit(std::size_t p) { return p & -p; }",
			"",
			"    void update(std::size_t p, value_type value)",
			"    {",
			"        while (p < arr.size())",
			"        {",
			"            arr[p] += value;",
			"            p += lowbit(p);",
			"        }",
			"    }",
			"",
			"    value_type query(std::size_t p)",
			"    {",
			"        value_type ans{};",
			"        while (p)",
			"        {",
			"            ans += arr[p];",
			"            p -= lowbit(p);",
			"        }",
			"        return ans;",
			"    }",
			"",
			"private:",
			"    std::vector<value_type> arr;",
			"};"
		],
		"description": "The BinaryIndexedTree template class"
	},

	"class SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"template<typename _ValueType>",
			"class SegmentTree",
			"{",
			"public:",
			"    using value_type = _ValueType;",
			"",
			"    std::vector<value_type> tree;",
			"",
			"    std::function<value_type(const value_type&, const value_type&)> merge;",
			"",
			"    explicit SegmentTree(",
			"        std::size_t n,",
			"        const decltype(merge)& func = [](const value_type& lv, const value_type& rv) -> value_type { return lv + rv; })",
			"            : tree(n << 2), merge(func)",
			"    { }",
			"",
			"    SegmentTree(",
			"        std::size_t n,",
			"        const value_type& value,",
			"        const decltype(merge)& func = [](const value_type& lv, const value_type& rv) -> value_type { return lv + rv; })",
			"            : tree(n << 2, value), merge(func)",
			"    { }",
			"",
			"    static constexpr std::size_t ls(std::size_t p) { return p << 1; }",
			"    static constexpr std::size_t rs(std::size_t p) { return p << 1 | 1; }",
			"",
			"    void push_up(int p)",
			"    {",
			"        tree[p] = merge(tree[ls(p)], tree[rs(p)]);",
			"    }",
			"",
			"    virtual void push_down(int p, int l, int r)",
			"    { }",
			"",
			"    void build(int p, int l, int r, const std::vector<value_type>& arr)",
			"    {",
			"        if (l == r)",
			"        {",
			"            tree[p] = arr[l];",
			"            return;",
			"        }",
			"",
			"        int mid = (l + r) >> 1;",
			"        build(ls(p), l, mid, arr);",
			"        build(rs(p), mid + 1, r, arr);",
			"",
			"        push_up(p);",
			"    }",
			"",
			"    value_type get_sum(int p, int l, int r, int x, int y)",
			"    {",
			"        if (x <= l and r <= y)",
			"            return tree[p];",
			"",
			"        push_down(p, l, r);",
			"",
			"        value_type res{};",
			"        int mid = (l + r) >> 1;",
			"",
			"        if (x <= mid)",
			"            res = merge(res, get_sum(ls(p), l, mid, x, y));",
			"        if (y > mid)",
			"            res = merge(res, get_sum(rs(p), mid + 1, r, x, y));",
			"",
			"        return res;",
			"    }",
			"};"
		],
		"description": "class SegmentTree"
	},

	"class LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"template<typename _ValueType, typename _LazyType>",
			"class LazySegmentTree : public SegmentTree<_ValueType>",
			"{",
			"public:",
			"    using value_type = _ValueType;",
			"    using lazy_type  = _LazyType;",
			"",
			"    using SegmentTree<_ValueType>::ls;",
			"    using SegmentTree<_ValueType>::rs;",
			"",
			"    using SegmentTree<_ValueType>::push_up;",
			"",
			"    using SegmentTree<_ValueType>::tree;",
			"",
			"    std::vector<lazy_type> lazy;",
			"",
			"    template<typename ...Args>",
			"    LazySegmentTree(Args&& ...args)",
			"        : SegmentTree<_ValueType>(args...), lazy(tree.size()) { }",
			"",
			"    virtual void add_lazy(int p, int l, int r, const value_type& v)",
			"    {",
			"        // sum",
			"        if constexpr (true)",
			"        {",
			"            lazy[p] += v;",
			"            tree[p] += (r - l + 1) * v;",
			"        }",
			"        // max/min",
			"        else",
			"        {",
			"            lazy[p] += v;",
			"            tree[p] += v;",
			"        }",
			"    }",
			"",
			"    virtual void push_down(int p, int l, int r) override",
			"    {",
			"        if (lazy[p])",
			"        {",
			"            int mid = (l + r) >> 1;",
			"",
			"            add_lazy(ls(p), l, mid, lazy[p]);",
			"            add_lazy(rs(p), mid + 1, r, lazy[p]);",
			"            lazy[p] = 0;",
			"        }",
			"    }",
			"",
			"    void update(int p, int l, int r, int x, int y, const value_type& v)",
			"    {",
			"        if (x <= l and r <= y)",
			"        {",
			"            add_lazy(p, l, r, v);",
			"            return;",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = (l + r) >> 1;",
			"",
			"        if (x <= mid)",
			"            update(ls(p), l, mid, x, y, v);",
			"        if (y > mid)",
			"            update(rs(p), mid + 1, r, x, y, v);",
			"        ",
			"        push_up(p);",
			"    }",
			"};"
		],
		"description": "class LazySegmentTree"
	},

	"The ScapegoatTree template class": {
		"prefix": "ScapegoatTree",
		"body": [
			"template<typename _ValueType, typename _Compare = std::less<_ValueType>>",
			"class ScapegoatTree",
			"{",
			"public:",
			"",
			"    using value_type = _ValueType;",
			"    using value_comp = _Compare;",
			"",
			"    struct node",
			"    {",
			"        int ls, rs;",
			"        int size;",
			"        int removed_size;",
			"",
			"        bool is_removed;",
			"",
			"        value_type value;",
			"    };",
			"",
			"    static constexpr const double alpha = 0.75;",
			"",
			"    explicit ScapegoatTree()",
			"        : tree(1) { }",
			"",
			"    int& root() const noexcept { return rootNode; }",
			"",
			"    int size() const noexcept",
			"    {",
			"        return tree[root()].size;",
			"    }",
			"",
			"    bool empty() const noexcept",
			"    {",
			"        return not(size());",
			"    }",
			"",
			"    const value_type& front() const noexcept",
			"    {",
			"        return (*this)[0];",
			"    }",
			"",
			"    const value_type& back() const noexcept",
			"    {",
			"        return (*this)[size() - 1];",
			"    }",
			"",
			"    bool check(int p) const",
			"    {",
			"        return std::max(tree[tree[p].ls].size, tree[tree[p].rs].size) > tree[p].size * alpha;",
			"    }",
			"",
			"    bool check_removed(int p) const",
			"    {",
			"        return std::max(",
			"            tree[tree[p].ls].removed_size + tree[tree[p].ls].size,",
			"            tree[tree[p].rs].removed_size + tree[tree[p].rs].size)",
			"                > (tree[p].removed_size + tree[p].size) * alpha;",
			"    }",
			"",
			"    void build(int& u, int l, int r, const std::vector<value_type>& que)",
			"    {",
			"        if (l == r) return;",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (u == 0)",
			"        {",
			"            u = push_node();",
			"            tree[u].size = 1;",
			"        }",
			"        tree[u].value = que[mid];",
			"",
			"        build(tree[u].ls, l, mid, que);",
			"        build(tree[u].rs, mid + 1, r, que);",
			"",
			"        tree[u].size = tree[tree[u].ls].size + tree[tree[u].rs].size + 1;",
			"        return;",
			"    }",
			"",
			"    void rebuild(int p)",
			"    {",
			"        std::vector<value_type> que(1);",
			"        que.reserve(tree[p].size + 1);",
			"",
			"        inorder(p, p, que);",
			"",
			"        tree[p] = node();",
			"        build(p, 1, que.size(), que);",
			"",
			"        return;",
			"    }",
			"",
			"    void insert(const value_type& value)",
			"    {",
			"        int rb = 0;",
			"        std::function<void(int&)> func = [&](int& u) -> void",
			"        {",
			"            if (u == 0)",
			"            {",
			"                u = push_node();",
			"                tree[u].value = value;",
			"                tree[u].size = 1;",
			"                return;",
			"            }",
			"",
			"            ++tree[u].size;",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                func(tree[u].ls);",
			"            else",
			"                func(tree[u].rs);",
			"",
			"            if (check(u))",
			"                rb = u;",
			"        };",
			"        if (recycle.empty() && tree.capacity() < tree.size() + 1)",
			"            tree.reserve(std::size_t(double(tree.size() + 1) * 1.5));",
			"",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"    }",
			"",
			"    bool erase(const value_type& value)",
			"    {",
			"        int rb = 0, rbr = 0;",
			"        std::function<bool(int)> func = [&](int u) -> bool",
			"        {",
			"            if (u == 0)",
			"            {",
			"                return false;",
			"            }",
			"",
			"            if (tree[u].is_removed == false",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                tree[u].is_removed = true;",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                return true;",
			"            }",
			"",
			"            bool ans = false;",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                ans |= func(tree[u].ls);",
			"            else",
			"                ans |= func(tree[u].rs);",
			"",
			"            if (ans)",
			"            {",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                if (check_removed(u))",
			"                {",
			"                    rb = u;",
			"                    rbr = tree[u].removed_size;",
			"                }",
			"                tree[u].removed_size -= rbr;",
			"            }",
			"            return ans;",
			"        };",
			"",
			"        bool ans = func(root());",
			"        if (rb) rebuild(rb);",
			"",
			"        return ans;",
			"    }",
			"",
			"    bool erase_at(int index)",
			"    {",
			"        if (index >= size()) return false;",
			"        int rb = 0, rbr = 0;",
			"        std::function<void(int)> func = [&](int u) -> void",
			"        {",
			"            if (u == 0) return;",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"            {",
			"                tree[u].is_removed = true;",
			"                --tree[u].size;",
			"                ++tree[u].removed_size;",
			"                return;",
			"            }",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                func(tree[u].ls);",
			"            else",
			"                index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"",
			"            ++tree[u].removed_size;",
			"            --tree[u].size;",
			"            if (check_removed(u))",
			"            {",
			"                rb = u;",
			"                rbr = tree[u].removed_size;",
			"            }",
			"            tree[u].removed_size -= rbr;",
			"        };",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"        return true;",
			"    }",
			"",
			"    int count(const value_type& value) const",
			"    {",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            bool equal = not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value);",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls) + equal;",
			"            else",
			"                return func(tree[u].rs) + equal;",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"    int indexof(const value_type& value, bool* const exist = nullptr) const",
			"    {",
			"        bool _exist = false;",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            if (not _exist",
			"                and not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                _exist = true;",
			"            }",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls);",
			"            else",
			"                return func(tree[u].rs) + tree[tree[u].ls].size + !tree[u].is_removed;",
			"        };",
			"        if (exist) *exist = _exist;",
			"        return func(root());",
			"    }",
			"",
			"    const value_type& operator[](int index) const",
			"    {",
			"        std::function<const value_type& (int)> func = [&](int u) -> const value_type&",
			"        {",
			"            if (u == 0)",
			"                return value_type();",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"                return tree[u].value;",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                return func(tree[u].ls);",
			"            else",
			"                return index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"protected:",
			"    int push_node()",
			"    {",
			"        if (recycle.size())",
			"        {",
			"            int top = recycle.back();",
			"            recycle.pop_back();",
			"            tree[top] = node();",
			"            return top;",
			"        }",
			"        else",
			"        {",
			"            tree.push_back(node());",
			"            return tree.size() - 1;",
			"        }",
			"    }",
			"",
			"    void inorder(int p, int np, std::vector<value_type>& que)",
			"    {",
			"        if (p == 0) return;",
			"",
			"        inorder(tree[p].ls, np, que);",
			"",
			"        if (tree[p].is_removed == false)",
			"            que.push_back(tree[p].value);",
			"",
			"        if (p != np)",
			"            recycle.push_back(p);",
			"",
			"        inorder(tree[p].rs, np, que);",
			"",
			"        return;",
			"    }",
			"",
			"private:",
			"    std::vector<node> tree;",
			"    std::vector<int>  recycle;",
			"",
			"    mutable int rootNode = 0;",
			"};"
		],
		"description": "The ScapegoatTree template class"
	},

	"The hash template class": {
		"prefix": "hash",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"/**",
			" * @struct hash",
			" * ",
			" * @brief Integer hashing",
			" */",
			"template<typename _Tp>",
			"struct hash",
			"{",
			"    using result_type = unsigned long long int;",
			"",
			"    static_assert(std::is_integral<_Tp>::value, \"This type is not an integer.\");",
			"",
			"    static result_type splitmix64(result_type x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    result_type operator()(_Tp x) const",
			"    {",
			"        static const result_type FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(FIXED_RANDOM + x);",
			"    }",
			"};",
			"",
			"/**",
			" * @struct hashes",
			" * ",
			" * @brief Based on @b BKDRHash algorithm",
			" * ",
			" * @tparam _VectorContainer Need to support access",
			" *                         using index ( @c [] ) and",
			" *                         include member function",
			" *                         @c size()",
			" * ",
			" * @tparam _Base A prime number",
			" * @tparam _Mod  A prime number",
			" */",
			"template<typename _VectorContainer, std::size_t _Base = 449, std::size_t _Mod = 436522843>",
			"struct hashes",
			"{",
			"    using result_type = unsigned long long int;",
			"",
			"    hashes() : _M_hashes(1)",
			"    {",
			"        if (_S_powers == nullptr)",
			"        {",
			"            _S_powers = new AutomaticallyExpandAndAssignVectorContainer<result_type>(",
			"                [](AutomaticallyExpandAndAssignVectorContainer<result_type>* __this, std::size_t __pos) -> result_type",
			"                    {",
			"                        if (__pos == 0)",
			"                            return 1;",
			"                        else",
			"                            return __this->back() * _Base % _Mod;",
			"                    });",
			"        }",
			"    }",
			"",
			"    hashes(const _VectorContainer& __list)",
			"        : hashes()",
			"    {",
			"        *this = __list;",
			"    }",
			"",
			"    /**",
			"     * @param __first Start of range",
			"     */",
			"    template<typename _ForwardIterator>",
			"    hashes(_ForwardIterator __first, _ForwardIterator __last)",
			"        : hashes()",
			"    {",
			"        for (; __first != __last; ++__first)",
			"        {",
			"            _M_hashes.push_back((_M_hashes.back() * _Base % _Mod + *__first) % _Mod);",
			"        }",
			"    }",
			"",
			"    hashes& operator=(const _VectorContainer& __list)",
			"    {",
			"        _M_hashes.resize(__list.size() + 1);",
			"",
			"        for (int i = 1; i <= __list.size(); ++i)",
			"        {",
			"            _M_hashes[i] = (_M_hashes[i - 1] * _Base % _Mod + __list[i - 1]) % _Mod;",
			"        }",
			"",
			"        return *this;",
			"    }",
			"",
			"    template<typename _VectorContainer2>",
			"    bool operator==(const _VectorContainer2& __list) const",
			"    {",
			"        return (*this)() == hashes<_VectorContainer2>::get(__list);",
			"    }",
			"",
			"    /**",
			"     * @brief Get the hash of a subarray",
			"     * ",
			"     * @param __l Left endpoint of the subarray",
			"     * @param __r Right endpoint of the subarray",
			"     * ",
			"     * @note Index starts at 0",
			"     */",
			"    result_type operator()(std::size_t __l = 0, std::size_t __r = -1) const",
			"    {",
			"        if (__l > __r)",
			"            std::swap(__l, __r);",
			"",
			"        __r = std::min(__r, static_cast<std::size_t>(std::max(0, static_cast<int>(_M_hashes.size()) - 2)));",
			"",
			"        return _M_hashes[__r + 1] - _M_hashes[__l] * (*_S_powers)[__r - __l + 1];",
			"    }",
			"",
			"    /**",
			"     * @brief Get the hash of @p __list without construction",
			"     */",
			"    static result_type get(const _VectorContainer& __list)",
			"    {",
			"        result_type res{};",
			"",
			"        for (int i = 0; i < __list.size(); ++i)",
			"        {",
			"            res = (res * _Base % _Mod + __list[i]) % _Mod;",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"    template<typename _ForwardIterator>",
			"    static result_type get(_ForwardIterator __first, _ForwardIterator __last)",
			"    {",
			"        result_type res{};",
			"",
			"        for (; __first != __last; ++__first)",
			"        {",
			"            res = (res * _Base % _Mod + *__first) % _Mod;",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"protected:",
			"",
			"    template<typename _Tp>",
			"    class AutomaticallyExpandAndAssignVectorContainer : public std::vector<_Tp>",
			"    {",
			"    public:",
			"        using value_type = _Tp;",
			"",
			"        AutomaticallyExpandAndAssignVectorContainer() = delete;",
			"",
			"        AutomaticallyExpandAndAssignVectorContainer(const std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>& __func)",
			"            : _M_assigner(__func)",
			"        { }",
			"",
			"        value_type& operator[](std::size_t __n)",
			"        {",
			"            _M_expand(__n + 1);",
			"            return std::vector<value_type>::operator[](__n);",
			"        }",
			"",
			"        void resize(std::size_t __new_size)",
			"        {",
			"            _M_expand(__new_size);",
			"            std::vector<value_type>::resize(__new_size);",
			"        }",
			"",
			"        void",
			"        set_assigner(const std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>& __new_assigner)",
			"        {",
			"            _M_assigner = __new_assigner;",
			"        }",
			"",
			"        std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>",
			"        get_assigner() const",
			"        {",
			"            return _M_assigner;",
			"        }",
			"",
			"    private:",
			"        void _M_expand(std::size_t __n)",
			"        {",
			"            while (this->size() < __n)",
			"            {",
			"                this->push_back(_M_assigner(this, this->size()));",
			"            }",
			"        }",
			"",
			"    private:",
			"        /**",
			"         * @param __this",
			"         * @param __pos",
			"         * ",
			"         * @return A value",
			"         */",
			"        std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)> _M_assigner;",
			"    };",
			"",
			"private:",
			"",
			"    std::vector<result_type> _M_hashes;",
			"",
			"    static inline AutomaticallyExpandAndAssignVectorContainer<result_type>* _S_powers;",
			"};"
		],
		"description": "The hash template class"
	},

	"The Lca class": {
		"prefix": "Lca",
		"body": [
			"class Lca",
			"{",
			"public:",
			"",
			"    const std::vector<std::vector<int>>& e;",
			"",
			"    std::vector<int> depth, head, wson, size, fa;",
			"",
			"    explicit Lca(const std::vector<std::vector<int>>& __e, int root = 1)",
			"        : e(__e), depth(e.size()), head(e.size()), wson(e.size()), size(e.size()), fa(e.size(), root)",
			"    {",
			"        build(root);",
			"        build_head(root, root);",
			"    }",
			"",
			"    int operator()(int x, int y)",
			"    {",
			"        while (head[x] != head[y])",
			"        {",
			"            if (depth[head[x]] > depth[head[y]])",
			"                x = fa[head[x]];",
			"            else",
			"                y = fa[head[y]];",
			"        }",
			"",
			"        if (depth[x] < depth[y])",
			"            return x;",
			"        else",
			"            return y;",
			"    }",
			"",
			"private:",
			"",
			"    void build(int p)",
			"    {",
			"        depth[p] = depth[fa[p]] + 1;",
			"        size[p] = 1;",
			"",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p])",
			"                continue;",
			"",
			"            fa[i] = p;",
			"",
			"            build(i);",
			"",
			"            size[p] += size[i];",
			"",
			"            if (size[i] > size[wson[p]])",
			"                wson[p] = i;",
			"        }",
			"    }",
			"",
			"    void build_head(int p, int top)",
			"    {",
			"        head[p] = top;",
			"",
			"        if (wson[p])",
			"            build_head(wson[p], top);",
			"        ",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p] or i == wson[p])",
			"                continue;",
			"",
			"            build_head(i, i);",
			"        }",
			"    }",
			"",
			"};"
		],
		"description": "The Lca class"
	}
}