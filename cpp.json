{
	"Headers": {
		"prefix": "headers",
		"body": [
			"/** Copyright (c) 2024 huanhuanonly. All rights reserved.",
			" * ",
			" * @file  ${TM_FILENAME_BASE}",
			" * ",
			" * @brief $1",
			" * ",
			" * Created by Yanghuanhuan (huanhuanonly@gmail.com) on ${CURRENT_DAY_NAME}, ${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]",
			" */",
			"",
			"$0"
		],
		"description": "Headers"
	},

	"Headle for problem": {
		"prefix": "problem_headle",
		"body": [
			"/**",
			" * ${1:ContestTitle}",
			" * ",
			" * => ${2:ProblemTitle} ( @c ${3:Rating} )",
			" * ",
			" * -> ${4:ProblemLink}",
			" * ",
			" * Submissions ~> ${5:SubmissionsLink} By huanhuanonly",
			" * ",
			" * @b ${6:AlgorithmLabel}",
			" * ",
			" * ----${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]----",
			"*/",
			"",
			"$0"
		],
		"description": "Headle for problem"
	},

	"Contest Template for C++": {
		"prefix": "contest",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using int8 = signed char;",
			"using int16 = short;",
			"using int32 = int;",
			"using int64 = long long;",
			"",
			"using uint8 = unsigned char;",
			"using uint16 = unsigned short;",
			"using uint32 = unsigned int;",
			"using uint64 = unsigned long long;",
			"",
			"#ifdef __GNUC__",
			"using int128 = __int128;",
			"using uint128 = unsigned __int128;",
			"#endif",
			"",
			"using real32 = float;",
			"using real64 = double;",
			"using real128 = long double;",
			"",
			"int main(void)",
			"{",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(nullptr), std::cout.tie(nullptr);",
			"",
			"    $0",
			"",
			"    return 0;",
			"}"
		],
		"description": "Contest Template for C++"
	},

	"IO stream redirection template": {
		"prefix": "fre",
		"body": [
			"#ifdef __localhost",
			"    ::freopen(\"in\", \"r\", stdin);",
			"    ::freopen(\"out\", \"w\", stdout);",
			"#endif"
		],
		"description": "IO stream redirection template"
	},

	"Range from first to last": {
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()"
		],
		"description": "Range from first to last"
	},

	"The is_prime() function": {
		"prefix": "is_prime",
		"body": [
			"template<typename _Tp>",
			"bool is_prime(_Tp n)",
			"{",
			"    if (n <= 3) return n > 1;",
			"",
			"    if (n % 6 != 1 && n % 6 != 5) return false;",
			"",
			"    for (int i = 5; i <= std::sqrt(n); i += 6)",
			"    {",
			"        if (n % i == 0 || n % (i + 2) == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "The is_prime() function"
	},

	"The miller_rabin() function": {
		"prefix": "is_prime",
		"body": [
			"template<typename _Tp>",
			"bool miller_rabin(_Tp n)",
			"{",
			"    constexpr _Tp test[10] = {2, 3, 5, 7, 11, 13, 17};",
			"",
			"    if (n == 1) return false;",
			"",
			"    _Tp t = n - 1, k = 0;",
			"",
			"    while (not(t & 1)) ++k, t >>= 1;",
			"",
			"    for (_Tp i = 0; i < 4; ++i)",
			"    {",
			"        if (n == test[i]) return true;",
			"",
			"        _Tp a = fast_power(test[i], t, n), nxt = a;",
			"        for (_Tp j = 1; j <= k; ++j)",
			"        {",
			"            nxt = (a * a) % n;",
			"            if (nxt == 1 && a != 1 && a != n - 1) return false;",
			"            a = nxt;",
			"        }",
			"        if (a != 1) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "The miller_rabin() function"
	},

	"The get_primeset() function": {
		"prefix": "get_primeset",
		"body": [
			"template<typename _Tp>",
			"std::vector<_Tp> get_primeset(_Tp n)",
			"{",
			"    std::vector<_Tp> result;",
			"    std::vector<bool> vis(n + 1);",
			"",
			"    vis[0] = vis[1] = true;",
			"",
			"    for (_Tp i = 2; i <= n; ++i)",
			"    {",
			"        if (vis[i] == false)",
			"            result.push_back(i);",
			"",
			"        for (std::size_t j = 0; j < result.size(); ++j)",
			"        {",
			"            if (i * result[j] > n) break;",
			"            vis[i * result[j]] = true;",
			"            if (i % result[j] == 0) break;",
			"        }",
			"    }",
			"    return result;",
			"}"
		],
		"description": "The get_primeset() function"
	},

	"The fast_mul() function": {
		"prefix": "fast_mul",
		"body": [
			"template<typename _Tp, typename _Mt>",
			"_Tp fast_mul(_Tp __fv, _Tp __sv, _Mt __mod)",
			"{",
			"    __fv %= __mod, __sv %= __mod;",
			"",
			"    _Tp res = 0;",
			"    for (; __sv; __fv = (__fv + __fv) % __mod, __sv >>= 1)",
			"        if (__sv & 1)",
			"            res = (res + __fv) % __mod;",
			"    return res;",
			"}"
		],
		"description": "fast_mul"
	},

	"The fast_power() function": {
		"prefix": "fast_power",
		"body": [
			"template<typename _Tp, typename _Mt>",
			"_Tp fast_power(_Tp __fv, _Tp __sv, _Mt __mod)",
			"{",
			"    __fv %= __mod;",
			"",
			"    _Tp ans = 1;",
			"    for (; __sv; __fv = (__fv * __fv) % __mod, __sv >>= 1)",
			"        if (__sv & 1)",
			"            ans = (ans * __fv) % __mod;",
			"    return ans;",
			"}"
		],
		"description": "fast_power"
	},

	"The prime_factorization() function": {
		"prefix": "prime_factorization",
		"body": [
			"template<typename T>",
			"std::vector<T> prime_factorization(T __n)",
			"{",
			"    std::vector<T> res;",
			"",
			"    for (int i = 2; i <= __n / i; ++i)",
			"    {",
			"        while (__n % i == 0)",
			"        {",
			"            res.push_back(i);",
			"            __n /= i;",
			"        }",
			"    }",
			"",
			"    if (__n != 1)",
			"        res.push_back(__n);",
			"",
			"    return res;",
			"}"
		],
		"description": "The prime_factorization() function"
	},

	"The Matrix template class": {
		"prefix": "Matrix",
		"body": [
			"template<typename _Tp, uint32 _RowCount, uint32 _ColumnCount>",
			"class Matrix",
			"{",
			"public:",
			"    ",
			"    using value_type = _Tp;",
			"    using pointer = _Tp*;",
			"    using const_pointer = const _Tp*;",
			"    using reference = _Tp&;",
			"    using const_reference = const _Tp&;",
			"",
			"    Matrix() = delete;",
			"",
			"    // Do nothing",
			"    Matrix(std::nullptr_t) noexcept",
			"    { }",
			"",
			"    Matrix(_Tp __value = _Tp{}) noexcept : Matrix(nullptr)",
			"    { fill(__value); }",
			"",
			"    template<typename _Generator = _Tp (*)(uint32, uint32)>",
			"    Matrix(_Generator __er) : Matrix(nullptr)",
			"    { fill(__er); }",
			"",
			"    Matrix(std::initializer_list<std::initializer_list<value_type>> __init) : Matrix(nullptr)",
			"    {",
			"        for_each([this, &__init](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = (",
			"                i < __init.size() and j < (__init.begin() + i)->size()",
			"                ? *((__init.begin() + i)->begin() + j)",
			"                : value_type(0));",
			"        });",
			"    }",
			"",
			"    void fill(value_type __value) noexcept",
			"    {",
			"        for_each([this, &__value](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __value;",
			"        });",
			"    }",
			"",
			"    template<typename _Generator = value_type (*)(uint32, uint32)>",
			"    void fill(_Generator __er)",
			"    {",
			"        for_each([this, &__er](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __er(i, j);",
			"        });",
			"    }",
			"",
			"    Matrix operator+(const Matrix& __it) const noexcept",
			"    {",
			"        Matrix res(nullptr);",
			"",
			"        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
			"        {",
			"            res[i][j] = _M_matrix[i][j] + __it._M_matrix[i][j];",
			"        });",
			"",
			"        return res;",
			"    }",
			"",
			"    Matrix& operator+=(const Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] += __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    Matrix operator-(const Matrix& __it) const noexcept",
			"    {",
			"        Matrix res(nullptr);",
			"",
			"        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
			"        {",
			"            res[i][j] = _M_matrix[i][j] - __it._M_matrix[i][j];",
			"        });",
			"",
			"        return res;",
			"    }",
			"",
			"    Matrix& operator-=(const Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] -= __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    template<uint32 _ItsColumnCount>",
			"    Matrix operator*(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it) const",
			"    {",
			"        Matrix res(nullptr);",
			"",
			"        for (uint32 i = 0; i < _RowCount; ++i)",
			"        {",
			"            for (uint32 j = 0; j < _ItsColumnCount; ++j)",
			"            {",
			"                for (uint32 k = 0; k < _ColumnCount; ++k)",
			"                {",
			"                    res._M_matrix[i][j] += _M_matrix[i][k] * __it._M_matrix[k][j];",
			"                }",
			"            }",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"",
			"    template<uint32 _ItsColumnCount>",
			"    Matrix& operator*=(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it)",
			"    {",
			"        swap(*this * __it);",
			"        return *this;",
			"    }",
			"",
			"    template<typename _ValueType>",
			"    std::enable_if_t<std::is_integral_v<_ValueType>, Matrix&> operator^=(_ValueType __pow)",
			"    {",
			"        Matrix res([](uint32 i, uint32 j) -> _Tp { return static_cast<_Tp>(i == j); });",
			"",
			"        for (; __pow; __pow >>= 1, *this *= *this)",
			"        {",
			"            if (__pow & 1)",
			"            {",
			"                res *= *this;",
			"            }",
			"        }",
			"",
			"        swap(std::move(res));",
			"        return *this;",
			"    }",
			"",
			"    constexpr reference at(uint32 __rowNumber, uint32 __colNumber) noexcept",
			"    { return _M_matrix[__rowNumber][__colNumber]; }",
			"",
			"    constexpr value_type at(uint32 __rowNumber, uint32 __colNumber) const noexcept",
			"    { return _M_matrix[__rowNumber][__colNumber]; }",
			"",
			"    void swap(Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
			"            __it._M_matrix[i][j] ^= _M_matrix[i][j];",
			"            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    void swap(Matrix&& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    constexpr uint32 row_count() const noexcept",
			"    { return _RowCount; }",
			"",
			"    constexpr uint32 column_count() const noexcept",
			"    { return _ColumnCount; }",
			"",
			"    template<typename _Function = void (*)(uint32, uint32)>",
			"    constexpr void for_each(_Function __func)",
			"    {",
			"        for (uint32 i = 0; i < _RowCount; ++i)",
			"        {",
			"            for (uint32 j = 0; j < _ColumnCount; ++j)",
			"            {",
			"                __func(i, j);",
			"            }",
			"        }",
			"    }",
			"",
			"    template<typename _ItsTp, uint32 _ItsRowCount, uint32 _ItsColumnCount>",
			"    friend class Matrix;",
			"",
			"protected:",
			"",
			"    value_type _M_matrix[_RowCount][_ColumnCount];",
			"};"
		],
		"description": "The Matrix template class"
	},

	"The manacher() function": {
		"prefix": "manacher",
		"body": [
			"int manacher(const std::string& str)",
			"{",
			"    std::string s(1, '^');",
			"    s.reserve(str.size() * 2 + 3);",
			"    ",
			"    for (int i = 0; i < str.size(); ++i)",
			"    {",
			"        s.push_back(' ');",
			"        s.push_back(str[i]);",
			"    }",
			"",
			"    s.push_back(' ');",
			"    s.push_back('$');",
			"",
			"    int c = 0, r = 0;",
			"",
			"    std::vector<int> dp(s.size());",
			"",
			"    int ans = 0;",
			"",
			"    for (int i = 1; i < s.size() - 1; ++i)",
			"    {",
			"        if (r >= i)",
			"            dp[i] = std::min(r - i, dp[c - (i - c)]);",
			"",
			"        while (s[i - dp[i] - 1] == s[i + dp[i] + 1])",
			"            ++dp[i];",
			"",
			"        if (dp[i] + i > r)",
			"        {",
			"            r = dp[i] + i;",
			"            c = i;",
			"        }",
			"",
			"        ans = std::max(ans, dp[i]);",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "The manacher() function"
	},

	"The get_z() function": {
		"prefix": "get_z",
		"body": [
			"std::vector<int> get_z(const std::string_view& s)",
			"{",
			"    std::vector<int> z(s.size());",
			"    ",
			"    z[0] = s.size();",
			"",
			"    int l = -1, r = 0;",
			"",
			"    for (int i = 1; i < s.size(); ++i)",
			"    {",
			"        if (i <= r)",
			"            z[i] = std::min(z[i - l], r - i + 1);",
			"",
			"        while (i + z[i] < s.size() and s[z[i]] == s[i + z[i]])",
			"            ++z[i];",
			"",
			"        if (i + z[i] - 1 > r)",
			"        {",
			"            r = i + z[i] - 1;",
			"            l = i;",
			"        }",
			"    }",
			"",
			"    return z;",
			"}"
		],
		"description": "The get_z() function"
	},

	"class DisjointSet: Merge by rank": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return tree[u].fa == u ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"            tree[fv].fa = fu;",
			"        else",
			"            tree[fu].fa = fv;",
			"        ",
			"        if (tree[fu].rank == tree[fv].rank)",
			"            ++tree[fv].rank;",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Merge by rank"
	},

	"class DisjointSet: Path Compression": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    std::vector<int> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        std::iota(tree.begin(), tree.end(), 0);",
			"    }",
			"",
			"    int find(int u)",
			"    {",
			"        return tree[u] == u ? u : tree[u] = find(tree[u]);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        tree[find(v)] = find(u);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Path Compression"
	},

	"class DisjointSet: with Undo": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    std::stack<std::pair<int&, int>, std::vector<std::pair<int&, int>>> ver_fa, ver_rank;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return is_root(u) ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"        {",
			"            ver_fa.push({tree[fv].fa, tree[fv].fa});",
			"            tree[fv].fa = fu;",
			"        }",
			"        else",
			"        {",
			"            ver_fa.push({tree[fu].fa, tree[fu].fa});",
			"            tree[fu].fa = fv;",
			"        }",
			"        ",
			"        ver_rank.push({tree[fv].rank, tree[fv].rank});",
			"        if (tree[fu].rank == tree[fv].rank)",
			"        {",
			"            ++tree[fv].rank;",
			"        }",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"",
			"    void undo()",
			"    {",
			"        if (not ver_fa.empty())",
			"        {",
			"            ver_fa.top().first = ver_fa.top().second;",
			"            ver_rank.top().first = ver_rank.top().second;",
			"",
			"            ver_fa.pop();",
			"            ver_rank.pop();",
			"        }",
			"    }",
			"};"
		],
		"description": "class DisjointSet: with Undo"
	},

	"The BinaryIndexedTree template class": {
		"prefix": "BinaryIndexedTree",
		"body": [
			"// Fenwick Tree",
			"template<typename _ValueType>",
			"class BinaryIndexedTree",
			"{",
			"public:",
			"    using value_type = _ValueType;",
			"",
			"    explicit BinaryIndexedTree(std::size_t n) : arr(n) { }",
			"",
			"    static constexpr inline std::size_t lowbit(std::size_t p) { return p & -p; }",
			"",
			"    void update(std::size_t p, value_type value)",
			"    {",
			"        while (p < arr.size())",
			"        {",
			"            arr[p] += value;",
			"            p += lowbit(p);",
			"        }",
			"    }",
			"",
			"    value_type query(std::size_t p)",
			"    {",
			"        value_type ans{};",
			"        while (p)",
			"        {",
			"            ans += arr[p];",
			"            p -= lowbit(p);",
			"        }",
			"        return ans;",
			"    }",
			"",
			"private:",
			"    std::vector<value_type> arr;",
			"};"
		],
		"description": "The BinaryIndexedTree template class"
	},

	"class SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"template<typename _ValueType>",
			"class SegmentTree",
			"{",
			"public:",
			"",
			"    using value_type = _ValueType;",
			"",
			"    explicit SegmentTree(std::size_t __n)",
			"            : tree(__n << 2)",
			"    { }",
			"",
			"    template<typename _MergeFunc>",
			"    explicit SegmentTree(std::size_t __n, _MergeFunc __func)",
			"            : tree(__n << 2), merge(__func)",
			"    { }",
			"",
			"    SegmentTree(std::size_t __n, const value_type& __value)",
			"            : tree(__n << 2, __value)",
			"    { }",
			"",
			"    template<typename _MergeFunc>",
			"    SegmentTree(std::size_t __n, const value_type& __value, _MergeFunc __func)",
			"            : tree(__n << 2, __value), merge(__func)",
			"    { }",
			"",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    SegmentTree(const _Container& __c)",
			"            : tree(std::size(__c) << 2)",
			"    { build(std::begin(__c)); }",
			"",
			"    template<typename _Container, typename _MergeFunc, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    SegmentTree(const _Container& __c, _MergeFunc __func)",
			"            : tree(std::size(__c) << 2), merge(__func)",
			"    { build(std::begin(__c)); }",
			"",
			"",
			"    constexpr int size() const noexcept",
			"    { return static_cast<int>(tree.size()) >> 2; }",
			"    ",
			"    template<typename _ForwardIterator>",
			"    void build(_ForwardIterator __first)",
			"    { _M_build(1, 1, static_cast<int>(size()), __first); }",
			"    ",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().begin())>>",
			"    void build(const _Container& __c)",
			"    { build(__c.begin()); }",
			"",
			"    template<std::size_t _StartingIndex, typename _Container, typename = std::void_t<decltype(std::declval<_Container>().begin())>>",
			"    void build(const _Container& __c)",
			"    { build(std::next(__c.begin(), _StartingIndex)); }",
			"",
			"",
			"    template<typename _ForwardIterator>",
			"    void to_vector(_ForwardIterator __first)",
			"    { _M_to_vector(1, 1, size(), __first); }",
			"",
			"    value_type sum(int __l, int __r)",
			"    { return _M_sum(1, 1, size(), __l + 1, __r + 1); }",
			"",
			"    value_type sum(int __p)",
			"    { return sum(__p, __p); }",
			"",
			"    const value_type& at(int __p)",
			"    { return _M_at(1, 1, size(), __p + 1); }",
			"",
			"    const value_type& operator[](int __p)",
			"    { return at(__p); }",
			"",
			"    template<typename _Tp>",
			"    void set(int __p, const _Tp& __value = value_type{})",
			"    {",
			"        _M_set(1, 1, size(), __p + 1, __value,",
			"            [](const value_type& [[maybe_unused]] __self, const _Tp& __value) {",
			"                return __value;",
			"            });",
			"    }",
			"",
			"    template<typename _Tp, typename _BinaryOperation>",
			"    void set(int __p, const _Tp& __value, _BinaryOperation __binary_op)",
			"    { _M_set(1, 1, size(), __p + 1, __value, __binary_op); }",
			"",
			"protected:",
			"",
			"    static constexpr int ls(int p) noexcept",
			"    { return p << 1; }",
			"",
			"    static constexpr int rs(int p) noexcept",
			"    { return p << 1 | 1; }",
			"",
			"    void push_up(int p)",
			"    { tree[p] = merge(tree[ls(p)], tree[rs(p)]); }",
			"",
			"    virtual void push_down(int p, int l, int r)",
			"    { }",
			"",
			"    template<typename _ForwardIterator>",
			"    void _M_build(int p, int l, int r, _ForwardIterator& it)",
			"    {",
			"        if (l == r)",
			"        {",
			"            tree[p] = *it;",
			"            ++it;",
			"",
			"            return;",
			"        }",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        _M_build(ls(p), l, mid, it);",
			"        _M_build(rs(p), mid + 1, r, it);",
			"",
			"        push_up(p);",
			"    }",
			"",
			"    template<typename _ForwardIterator>",
			"    void _M_to_vector(int p, int l, int r, _ForwardIterator& it)",
			"    {",
			"        if (l == r)",
			"        {",
			"            *it = tree[p];",
			"            ++it;",
			"",
			"            return;",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        _M_to_vector(ls(p), l, mid, it);",
			"        _M_to_vector(rs(p), mid + 1, r, it);",
			"    }",
			"",
			"    value_type _M_sum(int p, int l, int r, int x, int y)",
			"    {",
			"        if (x <= l and r <= y)",
			"        {",
			"            return tree[p];",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (x <= mid and y > mid)",
			"            return merge(_M_sum(ls(p), l, mid, x, y), _M_sum(rs(p), mid + 1, r, x, y));",
			"        else if (x <= mid)",
			"            return _M_sum(ls(p), l, mid, x, y);",
			"        else",
			"            return _M_sum(rs(p), mid + 1, r, x, y);",
			"    }",
			"",
			"    const value_type& _M_at(int p, int l, int r, int i)",
			"    {",
			"        if (l == r)",
			"        {",
			"            return tree[p];",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (i <= mid)",
			"            return _M_at(ls(p), l, r, i);",
			"        else",
			"            return _M_at(rs(p), mid + 1, r, i);",
			"    }",
			"",
			"    template<typename _Tp, typename _BinaryOperation>",
			"    void _M_set(int p, int l, int r, int i, const _Tp& v, const _BinaryOperation& bop)",
			"    {",
			"        if (l == r)",
			"        {",
			"            tree[p] = bop(tree[p], v);",
			"            return;",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (i <= mid)",
			"            _M_set(ls(p), l, mid, i, v, bop);",
			"        else",
			"            _M_set(rs(p), mid + 1, r, i, v, bop);",
			"",
			"        push_up(p);",
			"    }",
			"",
			"    std::vector<value_type> tree;",
			"    std::function<value_type(const value_type&, const value_type&)> merge = std::plus();",
			"};",
			"",
			"template<typename _Tp>",
			"SegmentTree(std::size_t, const _Tp&) -> SegmentTree<_Tp>;",
			"",
			"template<typename _Container>",
			"SegmentTree(const _Container&) -> SegmentTree<typename _Container::value_type>;",
			"}",
			""
		],
		"description": "class SegmentTree"
	},

	"class LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"template<typename _ValueType, typename _LazyType = _ValueType>",
			"class LazySegmentTree : public SegmentTree<_ValueType>",
			"{",
			"public:",
			"    using value_type = _ValueType;",
			"    using lazy_type  = _LazyType;",
			"",
			"    using SegmentTree<_ValueType>::ls;",
			"    using SegmentTree<_ValueType>::rs;",
			"    ",
			"    using SegmentTree<_ValueType>::size;",
			"",
			"    using SegmentTree<_ValueType>::push_up;",
			"",
			"    using SegmentTree<_ValueType>::tree;",
			"",
			"    template<typename... _Args>",
			"    explicit LazySegmentTree(_Args&&... __args)",
			"        : SegmentTree<_ValueType>(std::forward<_Args>(__args)...)",
			"        , lazy(tree.size())",
			"    { }",
			"",
			"    void set_interval(int __l, int __r, const value_type& __value)",
			"    { _M_set_interval(1, 1, size(), __l + 1, __r + 1, __value); }",
			"    ",
			"protected:",
			"    ",
			"    void add_lazy(int p, int l, int r, const value_type& v)",
			"    {",
			"        // sum",
			"        if constexpr (true)",
			"        {",
			"            lazy[p] += v;",
			"            tree[p] += (r - l + 1) * v;",
			"        }",
			"        // max/min",
			"        else",
			"        {",
			"            lazy[p] += v;",
			"            tree[p] += v;",
			"        }",
			"    }",
			"",
			"    void push_down(int p, int l, int r) override",
			"    {",
			"        if (lazy[p])",
			"        {",
			"            int mid = (l + r) >> 1;",
			"",
			"            add_lazy(ls(p), l, mid, lazy[p]);",
			"            add_lazy(rs(p), mid + 1, r, lazy[p]);",
			"            ",
			"            lazy[p] = lazy_type{};",
			"        }",
			"    }",
			"",
			"    void _M_set_interval(int p, int l, int r, int x, int y, const value_type& v)",
			"    {",
			"        if (x <= l and r <= y)",
			"        {",
			"            add_lazy(p, l, r, v);",
			"            return;",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = (l + r) >> 1;",
			"",
			"        if (x <= mid)",
			"            _M_set_interval(ls(p), l, mid, x, y, v);",
			"        if (y > mid)",
			"            _M_set_interval(rs(p), mid + 1, r, x, y, v);",
			"        ",
			"        push_up(p);",
			"    }",
			"",
			"protected:",
			"",
			"    std::vector<lazy_type> lazy;",
			"};",
			"",
			"template<typename _Tp>",
			"LazySegmentTree(std::size_t, const _Tp&) -> LazySegmentTree<_Tp>;",
			"",
			"template<typename _Container>",
			"LazySegmentTree(const _Container&) -> LazySegmentTree<typename _Container::value_type>;",
			"}"
		],
		"description": "class LazySegmentTree"
	},

	"The ScapegoatTree template class": {
		"prefix": "ScapegoatTree",
		"body": [
			"template<typename _ValueType, typename _Compare = std::less<_ValueType>>",
			"class ScapegoatTree",
			"{",
			"public:",
			"",
			"    using value_type = _ValueType;",
			"    using value_comp = _Compare;",
			"",
			"    struct node",
			"    {",
			"        int ls, rs;",
			"        int size;",
			"        int removed_size;",
			"",
			"        bool is_removed;",
			"",
			"        value_type value;",
			"    };",
			"",
			"    static constexpr const double alpha = 0.75;",
			"",
			"    explicit ScapegoatTree()",
			"        : tree(1) { }",
			"",
			"    int& root() const noexcept { return rootNode; }",
			"",
			"    int size() const noexcept",
			"    {",
			"        return tree[root()].size;",
			"    }",
			"",
			"    bool empty() const noexcept",
			"    {",
			"        return not(size());",
			"    }",
			"",
			"    const value_type& front() const noexcept",
			"    {",
			"        return (*this)[0];",
			"    }",
			"",
			"    const value_type& back() const noexcept",
			"    {",
			"        return (*this)[size() - 1];",
			"    }",
			"",
			"    bool check(int p) const",
			"    {",
			"        return std::max(tree[tree[p].ls].size, tree[tree[p].rs].size) > tree[p].size * alpha;",
			"    }",
			"",
			"    bool check_removed(int p) const",
			"    {",
			"        return std::max(",
			"            tree[tree[p].ls].removed_size + tree[tree[p].ls].size,",
			"            tree[tree[p].rs].removed_size + tree[tree[p].rs].size)",
			"                > (tree[p].removed_size + tree[p].size) * alpha;",
			"    }",
			"",
			"    void build(int& u, int l, int r, const std::vector<value_type>& que)",
			"    {",
			"        if (l == r) return;",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (u == 0)",
			"        {",
			"            u = push_node();",
			"            tree[u].size = 1;",
			"        }",
			"        tree[u].value = que[mid];",
			"",
			"        build(tree[u].ls, l, mid, que);",
			"        build(tree[u].rs, mid + 1, r, que);",
			"",
			"        tree[u].size = tree[tree[u].ls].size + tree[tree[u].rs].size + 1;",
			"        return;",
			"    }",
			"",
			"    void rebuild(int p)",
			"    {",
			"        std::vector<value_type> que(1);",
			"        que.reserve(tree[p].size + 1);",
			"",
			"        inorder(p, p, que);",
			"",
			"        tree[p] = node();",
			"        build(p, 1, que.size(), que);",
			"",
			"        return;",
			"    }",
			"",
			"    void insert(const value_type& value)",
			"    {",
			"        int rb = 0;",
			"        std::function<void(int&)> func = [&](int& u) -> void",
			"        {",
			"            if (u == 0)",
			"            {",
			"                u = push_node();",
			"                tree[u].value = value;",
			"                tree[u].size = 1;",
			"                return;",
			"            }",
			"",
			"            ++tree[u].size;",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                func(tree[u].ls);",
			"            else",
			"                func(tree[u].rs);",
			"",
			"            if (check(u))",
			"                rb = u;",
			"        };",
			"        if (recycle.empty() && tree.capacity() < tree.size() + 1)",
			"            tree.reserve(std::size_t(double(tree.size() + 1) * 1.5));",
			"",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"    }",
			"",
			"    bool erase(const value_type& value)",
			"    {",
			"        int rb = 0, rbr = 0;",
			"        std::function<bool(int)> func = [&](int u) -> bool",
			"        {",
			"            if (u == 0)",
			"            {",
			"                return false;",
			"            }",
			"",
			"            if (tree[u].is_removed == false",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                tree[u].is_removed = true;",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                return true;",
			"            }",
			"",
			"            bool ans = false;",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                ans |= func(tree[u].ls);",
			"            else",
			"                ans |= func(tree[u].rs);",
			"",
			"            if (ans)",
			"            {",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                if (check_removed(u))",
			"                {",
			"                    rb = u;",
			"                    rbr = tree[u].removed_size;",
			"                }",
			"                tree[u].removed_size -= rbr;",
			"            }",
			"            return ans;",
			"        };",
			"",
			"        bool ans = func(root());",
			"        if (rb) rebuild(rb);",
			"",
			"        return ans;",
			"    }",
			"",
			"    bool erase_at(int index)",
			"    {",
			"        if (index >= size()) return false;",
			"        int rb = 0, rbr = 0;",
			"        std::function<void(int)> func = [&](int u) -> void",
			"        {",
			"            if (u == 0) return;",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"            {",
			"                tree[u].is_removed = true;",
			"                --tree[u].size;",
			"                ++tree[u].removed_size;",
			"                return;",
			"            }",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                func(tree[u].ls);",
			"            else",
			"                index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"",
			"            ++tree[u].removed_size;",
			"            --tree[u].size;",
			"            if (check_removed(u))",
			"            {",
			"                rb = u;",
			"                rbr = tree[u].removed_size;",
			"            }",
			"            tree[u].removed_size -= rbr;",
			"        };",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"        return true;",
			"    }",
			"",
			"    int count(const value_type& value) const",
			"    {",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            bool equal = not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value);",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls) + equal;",
			"            else",
			"                return func(tree[u].rs) + equal;",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"    int indexof(const value_type& value, bool* const exist = nullptr) const",
			"    {",
			"        bool _exist = false;",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            if (not _exist",
			"                and not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                _exist = true;",
			"            }",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls);",
			"            else",
			"                return func(tree[u].rs) + tree[tree[u].ls].size + !tree[u].is_removed;",
			"        };",
			"        if (exist) *exist = _exist;",
			"        return func(root());",
			"    }",
			"",
			"    const value_type& operator[](int index) const",
			"    {",
			"        std::function<const value_type& (int)> func = [&](int u) -> const value_type&",
			"        {",
			"            if (u == 0)",
			"                return value_type();",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"                return tree[u].value;",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                return func(tree[u].ls);",
			"            else",
			"                return index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"protected:",
			"    int push_node()",
			"    {",
			"        if (recycle.size())",
			"        {",
			"            int top = recycle.back();",
			"            recycle.pop_back();",
			"            tree[top] = node();",
			"            return top;",
			"        }",
			"        else",
			"        {",
			"            tree.push_back(node());",
			"            return tree.size() - 1;",
			"        }",
			"    }",
			"",
			"    void inorder(int p, int np, std::vector<value_type>& que)",
			"    {",
			"        if (p == 0) return;",
			"",
			"        inorder(tree[p].ls, np, que);",
			"",
			"        if (tree[p].is_removed == false)",
			"            que.push_back(tree[p].value);",
			"",
			"        if (p != np)",
			"            recycle.push_back(p);",
			"",
			"        inorder(tree[p].rs, np, que);",
			"",
			"        return;",
			"    }",
			"",
			"private:",
			"    std::vector<node> tree;",
			"    std::vector<int>  recycle;",
			"",
			"    mutable int rootNode = 0;",
			"};"
		],
		"description": "The ScapegoatTree template class"
	},

	"The hash template class": {
		"prefix": "hash",
		"body": [
			"/**",
			" * @struct hash",
			" * ",
			" * @brief Integer hashing",
			" */",
			"template<typename _Tp>",
			"struct hash",
			"{",
			"    using result_type = unsigned long long int;",
			"",
			"    static_assert(std::is_integral<_Tp>::value, \"This type is not an integer.\");",
			"",
			"    static result_type splitmix64(result_type x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    result_type operator()(_Tp x) const",
			"    {",
			"        static const result_type FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(FIXED_RANDOM + x);",
			"    }",
			"};",
			"",
			"/**",
			" * @struct hashes",
			" * ",
			" * @brief Based on @b BKDRHash algorithm",
			" * ",
			" * @tparam _VectorContainer Need to support access",
			" *                         using index ( @c [] ) and",
			" *                         include member function",
			" *                         @c size()",
			" * ",
			" * @tparam _Base A prime number",
			" * @tparam _Mod  A prime number",
			" */",
			"template<typename _VectorContainer, std::size_t _Base = 449, std::size_t _Mod = 436522843>",
			"struct hashes",
			"{",
			"    using result_type = unsigned long long int;",
			"",
			"    hashes() : _M_hashes(1)",
			"    {",
			"        if (_S_powers == nullptr)",
			"        {",
			"            _S_powers = new AutomaticallyExpandAndAssignVectorContainer<result_type>(",
			"                [](AutomaticallyExpandAndAssignVectorContainer<result_type>* __this, std::size_t __pos) -> result_type",
			"                    {",
			"                        if (__pos == 0)",
			"                            return 1;",
			"                        else",
			"                            return __this->back() * _Base % _Mod;",
			"                    });",
			"        }",
			"    }",
			"",
			"    hashes(const _VectorContainer& __list)",
			"        : hashes()",
			"    {",
			"        *this = __list;",
			"    }",
			"",
			"    /**",
			"     * @param __first Start of range",
			"     */",
			"    template<typename _ForwardIterator>",
			"    hashes(_ForwardIterator __first, _ForwardIterator __last)",
			"        : hashes()",
			"    {",
			"        for (; __first != __last; ++__first)",
			"        {",
			"            _M_hashes.push_back((_M_hashes.back() * _Base % _Mod + *__first) % _Mod);",
			"        }",
			"    }",
			"",
			"    hashes& operator=(const _VectorContainer& __list)",
			"    {",
			"        _M_hashes.resize(__list.size() + 1);",
			"",
			"        for (int i = 1; i <= __list.size(); ++i)",
			"        {",
			"            _M_hashes[i] = (_M_hashes[i - 1] * _Base % _Mod + __list[i - 1]) % _Mod;",
			"        }",
			"",
			"        return *this;",
			"    }",
			"",
			"    template<typename _VectorContainer2>",
			"    bool operator==(const _VectorContainer2& __list) const",
			"    {",
			"        return (*this)() == hashes<_VectorContainer2>::get(__list);",
			"    }",
			"",
			"    /**",
			"     * @brief Get the hash of a subarray",
			"     * ",
			"     * @param __l Left endpoint of the subarray",
			"     * @param __r Right endpoint of the subarray",
			"     * ",
			"     * @note Index starts at 0",
			"     */",
			"    result_type operator()(std::size_t __l = 0, std::size_t __r = -1) const",
			"    {",
			"        if (__l > __r)",
			"            std::swap(__l, __r);",
			"",
			"        __r = std::min(__r, static_cast<std::size_t>(std::max(0, static_cast<int>(_M_hashes.size()) - 2)));",
			"",
			"        return _M_hashes[__r + 1] - _M_hashes[__l] * (*_S_powers)[__r - __l + 1];",
			"    }",
			"",
			"    /**",
			"     * @brief Get the hash of @p __list without construction",
			"     */",
			"    static result_type get(const _VectorContainer& __list)",
			"    {",
			"        result_type res{};",
			"",
			"        for (int i = 0; i < __list.size(); ++i)",
			"        {",
			"            res = (res * _Base % _Mod + __list[i]) % _Mod;",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"    template<typename _ForwardIterator>",
			"    static result_type get(_ForwardIterator __first, _ForwardIterator __last)",
			"    {",
			"        result_type res{};",
			"",
			"        for (; __first != __last; ++__first)",
			"        {",
			"            res = (res * _Base % _Mod + *__first) % _Mod;",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"protected:",
			"",
			"    template<typename _Tp>",
			"    class AutomaticallyExpandAndAssignVectorContainer : public std::vector<_Tp>",
			"    {",
			"    public:",
			"        using value_type = _Tp;",
			"",
			"        AutomaticallyExpandAndAssignVectorContainer() = delete;",
			"",
			"        AutomaticallyExpandAndAssignVectorContainer(const std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>& __func)",
			"            : _M_assigner(__func)",
			"        { }",
			"",
			"        value_type& operator[](std::size_t __n)",
			"        {",
			"            _M_expand(__n + 1);",
			"            return std::vector<value_type>::operator[](__n);",
			"        }",
			"",
			"        void resize(std::size_t __new_size)",
			"        {",
			"            _M_expand(__new_size);",
			"            std::vector<value_type>::resize(__new_size);",
			"        }",
			"",
			"        void",
			"        set_assigner(const std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>& __new_assigner)",
			"        {",
			"            _M_assigner = __new_assigner;",
			"        }",
			"",
			"        std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)>",
			"        get_assigner() const",
			"        {",
			"            return _M_assigner;",
			"        }",
			"",
			"    private:",
			"        void _M_expand(std::size_t __n)",
			"        {",
			"            while (this->size() < __n)",
			"            {",
			"                this->push_back(_M_assigner(this, this->size()));",
			"            }",
			"        }",
			"",
			"    private:",
			"        /**",
			"         * @param __this",
			"         * @param __pos",
			"         * ",
			"         * @return A value",
			"         */",
			"        std::function<value_type(AutomaticallyExpandAndAssignVectorContainer*, std::size_t)> _M_assigner;",
			"    };",
			"",
			"private:",
			"",
			"    std::vector<result_type> _M_hashes;",
			"",
			"    static inline AutomaticallyExpandAndAssignVectorContainer<result_type>* _S_powers;",
			"};"
		],
		"description": "The hash template class"
	},

	"The Mod template class": {
		"prefix": "Mod",
		"body": [
			"template<typename _Tp, _Tp _Mod = std::numeric_limits<_Tp>::max(),",
			"         typename _Enable = std::void_t<decltype(std::declval<_Tp>() % std::declval<_Tp>())>>",
			"class Mod",
			"{",
			"public:",
			"    ",
			"    using value_type = _Tp;",
			"",
			"    static_assert(std::is_same_v<_Enable, std::void_t<>>,",
			"                    \"The last template parameter is only used to restrict the _Tp.\");",
			"",
			"    Mod(value_type __value = value_type{}) : _M_value(__value % _S_mod) { }",
			"",
			"    Mod& set_mod(value_type __mod) noexcept",
			"    { _S_mod = __mod; _M_value %= __mod; }",
			"",
			"    static void init_mod(value_type __mod) noexcept",
			"    { _S_mod = __mod; }",
			"",
			"    static constexpr value_type mod() noexcept",
			"    { return _S_mod; }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    std::strong_ordering operator<=>(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return _M_value <=> __it._M_value; }",
			"",
			"    operator value_type() const noexcept",
			"    { return _M_value; }",
			"    ",
			"    operator bool() const noexcept",
			"    { return static_cast<bool>(_M_value); }",
			"",
			"    Mod operator~() const noexcept",
			"    { return Mod(~_M_value); }",
			"",
			"    Mod operator!() const noexcept",
			"    { return Mod(!_M_value); }",
			"",
			"    Mod operator-() const noexcept",
			"    { return Mod(-_M_value); }",
			"",
			"    constexpr value_type operator*() const noexcept",
			"    { return _M_value; }",
			"",
			"    constexpr value_type value() const noexcept",
			"    { return _M_value; }",
			"",
			"    Mod abs() const noexcept",
			"    { return Mod(std::abs(_M_value)); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod operator+(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return Mod(_M_value + __it._M_value); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod operator-(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return Mod(_M_value - __it._M_value % _S_mod + _S_mod); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod operator*(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return _S_quick_mul(*this, __it); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod operator/(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return Mod(_M_value * __it.pow(_S_mod - 2)); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod operator%(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return Mod(_M_value % __it._M_value); }",
			"",
			"    template<typename _ValueType>",
			"    std::enable_if_t<std::is_integral_v<_ValueType>, Mod> pow(_ValueType __it) noexcept",
			"    {",
			"        Mod ans(1);",
			"        for (; __it; *this *= *this, __it >>= 1)",
			"            if (__it & 1)",
			"                ans *= *this;",
			"        return ans;",
			"    }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() & std::declval<_ValueType>())>>",
			"    Mod operator&(_ValueType __it) const noexcept",
			"    { return Mod(_M_value & __it); }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() | std::declval<_ValueType>())>>",
			"    Mod operator|(_ValueType __it) const noexcept",
			"    { return Mod(_M_value | __it); }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() ^ std::declval<_ValueType>())>>",
			"    Mod operator^(_ValueType __it) const noexcept",
			"    { return Mod(_M_value ^ __it); }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() << std::declval<_ValueType>())>>",
			"    Mod operator<<(_ValueType __it) const noexcept",
			"    { return Mod(_M_value << __it); }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() >> std::declval<_ValueType>())>>",
			"    Mod operator>>(_ValueType __it) const noexcept",
			"    { return Mod(_M_value >> __it); }",
			"",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod& operator+=(Mod<_ItTp, _ItMod> __it) noexcept",
			"    { return (_M_value += __it._M_value) %= _S_mod, *this; }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod& operator-=(Mod<_ItTp, _ItMod> __it) noexcept",
			"    { return ((_M_value -= __it._M_value % _S_mod) += _S_mod) %= _S_mod, *this; }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod& operator*=(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return *this = _S_quick_mul(*this, __it); }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod& operator/=(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return (_M_value *= __it.pow(_S_mod - 2)._M_value) %= _S_mod, *this; }",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    Mod& operator%=(Mod<_ItTp, _ItMod> __it) const noexcept",
			"    { return _M_value %= __it._M_value, *this; }",
			"",
			"    template<typename _ValueType>",
			"    std::enable_if_t<std::is_integral_v<_ValueType>, Mod&> pow_equal(_ValueType __it) noexcept",
			"    { return *this = pow(__it); }",
			"",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() & std::declval<_ValueType>())>>",
			"    Mod& operator&=(_ValueType __it) noexcept",
			"    { return _M_value = (_M_value & __it) % _S_mod, *this; }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() | std::declval<_ValueType>())>>",
			"    Mod& operator|=(_ValueType __it) noexcept",
			"    { return _M_value = (_M_value | __it) % _S_mod, *this; }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() ^ std::declval<_ValueType>())>>",
			"    Mod& operator^=(_ValueType __it) noexcept",
			"    { return _M_value = (_M_value ^ __it) % _S_mod, *this; }",
			"",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() << std::declval<_ValueType>())>>",
			"    Mod& operator<<=(_ValueType __it) noexcept",
			"    { return _M_value = (_M_value << __it) % _S_mod, *this; }",
			"    ",
			"    template<typename _ValueType, typename = std::void_t<decltype(std::declval<value_type>() >> std::declval<_ValueType>())>>",
			"    Mod& operator>>=(_ValueType __it) noexcept",
			"    { return _M_value = (_M_value >> __it) % _S_mod, *this; }",
			"",
			"",
			"    Mod& operator++() noexcept",
			"    { return _M_value += 1, *this; }",
			"",
			"    Mod operator++(int) noexcept",
			"    { return _M_value += 1, Mod(_M_value - 1); }",
			"",
			"    Mod& operator--() noexcept",
			"    { return _M_value -= 1, *this; }",
			"",
			"    Mod operator--(int) noexcept",
			"    { return _M_value -= 1, Mod(_M_value + 1); }",
			"",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    friend std::istream& operator>>(std::istream& __is, Mod<_ItTp, _ItMod>& __this) noexcept;",
			"",
			"    template<typename _ItTp, _ItTp _ItMod>",
			"    friend std::ostream& operator<<(std::ostream& __os, Mod<_ItTp, _ItMod> __this) noexcept;",
			"",
			"    template<typename _ItTp, _ItTp _ItMod, typename>",
			"    friend class Mod;",
			"",
			"private:",
			"",
			"    static Mod _S_quick_mul(Mod __fv, Mod __sv)",
			"    {",
			"        Mod ans(0);",
			"        for (; __sv; __fv += __fv, __sv >>= 1)",
			"            if (__sv._M_value & 1)",
			"                ans += __fv;",
			"        return ans;",
			"    }",
			"",
			"protected:",
			"",
			"    value_type _M_value;",
			"    static value_type _S_mod;",
			"};",
			"",
			"template<typename _Tp, _Tp _Mod, typename _Enable>",
			"Mod<_Tp, _Mod, _Enable>::value_type Mod<_Tp, _Mod, _Enable>::_S_mod = _Mod;",
			"",
			"template<typename _ItTp, _ItTp _ItMod>",
			"std::istream& operator>>(std::istream& __is, Mod<_ItTp, _ItMod>& __this) noexcept",
			"{ return __is >> __this._M_value; }",
			"",
			"template<typename _ItTp, _ItTp _ItMod>",
			"std::ostream& operator<<(std::ostream& __os, Mod<_ItTp, _ItMod> __this) noexcept",
			"{ return __os << __this._M_value; }",
			""
		],
		"description": "Mod"
	},

	"The Lca class": {
		"prefix": "Lca",
		"body": [
			"class Lca",
			"{",
			"public:",
			"",
			"    const std::vector<std::vector<int>>& e;",
			"",
			"    std::vector<int> depth, head, wson, size, fa;",
			"",
			"    explicit Lca(const std::vector<std::vector<int>>& __e, int root = 1)",
			"        : e(__e), depth(e.size()), head(e.size()), wson(e.size()), size(e.size()), fa(e.size(), root)",
			"    {",
			"        build(root);",
			"        build_head(root, root);",
			"    }",
			"",
			"    int operator()(int x, int y)",
			"    {",
			"        while (head[x] != head[y])",
			"        {",
			"            if (depth[head[x]] > depth[head[y]])",
			"                x = fa[head[x]];",
			"            else",
			"                y = fa[head[y]];",
			"        }",
			"",
			"        if (depth[x] < depth[y])",
			"            return x;",
			"        else",
			"            return y;",
			"    }",
			"",
			"private:",
			"",
			"    void build(int p)",
			"    {",
			"        depth[p] = depth[fa[p]] + 1;",
			"        size[p] = 1;",
			"",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p])",
			"                continue;",
			"",
			"            fa[i] = p;",
			"",
			"            build(i);",
			"",
			"            size[p] += size[i];",
			"",
			"            if (size[i] > size[wson[p]])",
			"                wson[p] = i;",
			"        }",
			"    }",
			"",
			"    void build_head(int p, int top)",
			"    {",
			"        head[p] = top;",
			"",
			"        if (wson[p])",
			"            build_head(wson[p], top);",
			"        ",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p] or i == wson[p])",
			"                continue;",
			"",
			"            build_head(i, i);",
			"        }",
			"    }",
			"",
			"};"
		],
		"description": "The Lca class"
	}
}