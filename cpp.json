{
	"Headers": {
		"prefix": "headers",
		"body": [
			"/** Copyright (c) 2024 huanhuanonly. All rights reserved.",
			" * ",
			" * @file  ${TM_FILENAME_BASE}",
			" * ",
			" * @brief $1",
			" * ",
			" * Created by Yanghuanhuan (huanhuanonly@gmail.com) on ${CURRENT_DAY_NAME}, ${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]",
			" */",
			"",
			"$0"
		],
		"description": "Headers"
	},

	"Problem Metadata Header": {
		"prefix": "problem_metadata_header",
		"body": [
			"/**",
			" * ${1:ContestTitle}",
			" * ",
			" * => ${2:ProblemTitle} ( @c ${3:Rating} )",
			" * ",
			" * -> ${4:ProblemLink}",
			" * ",
			" * Submissions ~> ${5:SubmissionsLink} By huanhuanonly",
			" * ",
			" * @b ${6:AlgorithmLabel}",
			" * ",
			" * ----${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]----",
			"*/",
			"",
			"$0"
		],
		"description": "Problem Metadata Header"
	},

	"Contest Template for C++": {
		"prefix": "contest",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using int8 = signed char;",
			"using int16 = short;",
			"using int32 = int;",
			"using int64 = long long;",
			"",
			"using uint8 = unsigned char;",
			"using uint16 = unsigned short;",
			"using uint32 = unsigned int;",
			"using uint64 = unsigned long long;",
			"",
			"#ifdef __GNUC__",
			"using int128 = __int128;",
			"using uint128 = unsigned __int128;",
			"#endif",
			"",
			"using real32 = float;",
			"using real64 = double;",
			"using real128 = long double;",
			"",
			"int main(void)",
			"{",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(nullptr), std::cout.tie(nullptr);",
			"",
			"    $0",
			"",
			"    return 0;",
			"}"
		],
		"description": "Contest Template for C++"
	},

	"IO stream redirection template": {
		"prefix": "fre",
		"body": [
			"#ifdef __huanhuanonly_localhost",
			"    ::freopen(\"in\", \"r\", stdin);",
			"    ::freopen(\"out\", \"w\", stdout);",
			"#endif"
		],
		"description": "IO stream redirection template"
	},

	"Range from first to last": {
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()"
		],
		"description": "Range from first to last"
	},

	"The is_prime() function": {
		"prefix": "is_prime",
		"body": [
			"template<typename _Tp>",
			"[[nodiscard]] constexpr bool is_prime(_Tp n)",
			"{",
			"    if (n <= 3)",
			"    {",
			"        return n > 1;",
			"    }",
			"    else if (n % 6 != 1 and n % 6 != 5)",
			"    {",
			"        return false;",
			"    }",
			"",
			"    for (_Tp i = 5; i * i <= n; i += 6)",
			"    {",
			"        if (n % i == 0 or n % (i + 2) == 0)",
			"        {",
			"            return false;",
			"        }",
			"    }",
			"",
			"    return true;",
			"}"
		],
		"description": "The is_prime() function"
	},

	"The miller_rabin() function": {
		"prefix": "is_prime",
		"body": [
			"template<typename _Tp>",
			"[[nodiscard]] constexpr bool miller_rabin(_Tp n)",
			"{",
			"    constexpr std::array<_Tp, 7> primes{2, 3, 5, 7, 11, 13, 17};",
			"",
			"    if (n <= 1)",
			"    {",
			"        return false;",
			"    }",
			"",
			"    _Tp t = n - 1, k = 0;",
			"",
			"    for (; (t & 1) == 0; t >>= 1, ++k);",
			"",
			"    for (_Tp i = 0; i < primes.size(); ++i)",
			"    {",
			"        if (n == primes[i])",
			"        {",
			"            return true;",
			"        }",
			"",
			"        _Tp x = binary_exponentiation(primes[i], t, n);",
			"        _Tp next = x;",
			"",
			"        for (_Tp j = 1; j <= k; ++j)",
			"        {",
			"            next = (x * x) % n;",
			"",
			"            if (next == 1 and x != 1 and x != n - 1)",
			"            {",
			"                return false;",
			"            }",
			"",
			"            x = next;",
			"        }",
			"",
			"        if (x != 1)",
			"        {",
			"            return false;",
			"        }",
			"    }",
			"",
			"    return true;",
			"}"
		],
		"description": "The miller_rabin() function"
	},

	"The primes_in_range() function": {
		"prefix": "primes_in_range",
		"body": [
			"template<typename _Container = std::vector<int>>",
			"[[nodiscard]] constexpr _Container primes_in_range(std::size_t __n)",
			"{",
			"    _Container primes;",
			"",
			"    std::vector<bool> vis(__n + 1);",
			"",
			"    vis[0] = vis[1] = true;",
			"",
			"    for (std::size_t i = 2; i <= __n; ++i)",
			"    {",
			"        if (not vis[i])",
			"        {",
			"            primes.push_back(static_cast<_Container::value_type>(i));",
			"        }",
			"",
			"        for (const auto p : primes | std::views::take_while([__n, i](auto p) -> bool { return i * p <= __n; }))",
			"        {",
			"            vis[i * p] = true;",
			"",
			"            if (i % p == 0)",
			"            {",
			"                break;",
			"            }",
			"        }",
			"    }",
			"",
			"    return primes;",
			"}"
		],
		"description": "The primes_in_range() function"
	},

	"The binary_multiplication() function": {
		"prefix": "binary_multiplication",
		"body": [
			"template<typename _Tp>",
			"[[nodiscard]] constexpr _Tp binary_multiplication(_Tp __fv, _Tp __sv, _Tp __mod)",
			"{",
			"    auto res = static_cast<_Tp>(0);",
			"    ",
			"    for (__fv %= __mod, __sv %= __mod; __sv; __fv = (__fv + __fv) % __mod, __sv >>= 1)",
			"    {",
			"        if (__sv & 1)",
			"        {",
			"            res = (res + __fv) % __mod;",
			"        }",
			"    }",
			"",
			"    return res;",
			"}"
		],
		"description": "The binary_multiplication() function"
	},

	"The binary_exponentiation() function": {
		"prefix": "binary_exponentiation",
		"body": [
			"template<typename _Tp>",
			"[[nodiscard]] constexpr _Tp binary_exponentiation(_Tp __fv, _Tp __sv, _Tp __mod)",
			"{",
			"    auto res = static_cast<_Tp>(1);",
			"",
			"    for (__fv %= __mod; __sv; __fv = (__fv * __fv) % __mod, __sv >>= 1)",
			"    {",
			"        if (__sv & 1)",
			"        {",
			"            res = (res * __fv) % __mod;",
			"        }",
			"    }",
			"",
			"    return res;",
			"}"
		],
		"description": "The binary_exponentiation() function"
	},

	"The prime_factorization() function": {
		"prefix": "prime_factorization",
		"body": [
			"template<typename _Tp>",
			"[[nodiscard]] std::vector<_Tp> prime_factorization(_Tp __n)",
			"{",
			"    std::vector<_Tp> res;",
			"",
			"    for (int i = 2; i * i <= __n; ++i)",
			"    {",
			"        for (; __n % i == 0; __n /= i)",
			"        {",
			"            res.push_back(i);",
			"        }",
			"    }",
			"",
			"    if (__n != 1)",
			"    {",
			"        res.push_back(__n);",
			"    }",
			"",
			"    return res;",
			"}"
		],
		"description": "The prime_factorization() function"
	},

	"The Matrix template class": {
		"prefix": "Matrix",
		"body": [
			"template<typename _Tp, uint32 _RowCount, uint32 _ColumnCount>",
			"class Matrix",
			"{",
			"public:",
			"    ",
			"    using value_type = _Tp;",
			"    using pointer = _Tp*;",
			"    using const_pointer = const _Tp*;",
			"    using reference = _Tp&;",
			"    using const_reference = const _Tp&;",
			"",
			"    // Do nothing",
			"    Matrix(std::nullptr_t) noexcept",
			"    { }",
			"",
			"    Matrix(_Tp __value = _Tp{}) noexcept : Matrix(nullptr)",
			"    { fill(__value); }",
			"",
			"    template<typename _Generator = _Tp (*)(uint32, uint32)>",
			"    Matrix(_Generator __er) : Matrix(nullptr)",
			"    { fill(__er); }",
			"",
			"    Matrix(std::initializer_list<std::initializer_list<value_type>> __init) : Matrix(nullptr)",
			"    {",
			"        for_each([this, &__init](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = (",
			"                i < __init.size() and j < (__init.begin() + i)->size()",
			"                ? *((__init.begin() + i)->begin() + j)",
			"                : value_type(0));",
			"        });",
			"    }",
			"",
			"    void fill(value_type __value) noexcept",
			"    {",
			"        for_each([this, &__value](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __value;",
			"        });",
			"    }",
			"",
			"    template<typename _Generator = value_type (*)(uint32, uint32)>",
			"    void fill(_Generator __er)",
			"    {",
			"        for_each([this, &__er](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __er(i, j);",
			"        });",
			"    }",
			"",
			"    Matrix operator+(const Matrix& __it) const noexcept",
			"    {",
			"        Matrix res(nullptr);",
			"",
			"        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
			"        {",
			"            res[i][j] = _M_matrix[i][j] + __it._M_matrix[i][j];",
			"        });",
			"",
			"        return res;",
			"    }",
			"",
			"    Matrix& operator+=(const Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] += __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    Matrix operator-(const Matrix& __it) const noexcept",
			"    {",
			"        Matrix res(nullptr);",
			"",
			"        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
			"        {",
			"            res[i][j] = _M_matrix[i][j] - __it._M_matrix[i][j];",
			"        });",
			"",
			"        return res;",
			"    }",
			"",
			"    Matrix& operator-=(const Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] -= __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    template<uint32 _ItsColumnCount>",
			"    Matrix operator*(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it) const",
			"    {",
			"        Matrix res;",
			"",
			"        for (uint32 i = 0; i < _RowCount; ++i)",
			"        {",
			"            for (uint32 j = 0; j < _ItsColumnCount; ++j)",
			"            {",
			"                for (uint32 k = 0; k < _ColumnCount; ++k)",
			"                {",
			"                    res._M_matrix[i][j] += _M_matrix[i][k] * __it._M_matrix[k][j];",
			"                }",
			"            }",
			"        }",
			"",
			"        return res;",
			"    }",
			"",
			"",
			"    template<uint32 _ItsColumnCount>",
			"    Matrix& operator*=(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it)",
			"    {",
			"        swap(*this * __it);",
			"        return *this;",
			"    }",
			"",
			"    template<typename _ValueType>",
			"    std::enable_if_t<std::is_integral_v<_ValueType>, Matrix&> operator^=(_ValueType __pow)",
			"    {",
			"        Matrix res([](uint32 i, uint32 j) -> _Tp { return static_cast<_Tp>(i == j); });",
			"",
			"        for (; __pow; __pow >>= 1, *this *= *this)",
			"        {",
			"            if (__pow & 1)",
			"            {",
			"                res *= *this;",
			"            }",
			"        }",
			"",
			"        swap(std::move(res));",
			"        return *this;",
			"    }",
			"",
			"    constexpr reference at(uint32 __rowNumber, uint32 __colNumber) noexcept",
			"    { return _M_matrix[__rowNumber][__colNumber]; }",
			"",
			"    constexpr value_type at(uint32 __rowNumber, uint32 __colNumber) const noexcept",
			"    { return _M_matrix[__rowNumber][__colNumber]; }",
			"",
			"    void swap(Matrix& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
			"            __it._M_matrix[i][j] ^= _M_matrix[i][j];",
			"            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    void swap(Matrix&& __it) noexcept",
			"    {",
			"        for_each([this, &__it](uint32 i, uint32 j) -> void",
			"        {",
			"            _M_matrix[i][j] = __it._M_matrix[i][j];",
			"        });",
			"    }",
			"",
			"    constexpr uint32 row_count() const noexcept",
			"    { return _RowCount; }",
			"",
			"    constexpr uint32 column_count() const noexcept",
			"    { return _ColumnCount; }",
			"",
			"    template<typename _Function = void (*)(uint32, uint32)>",
			"    constexpr void for_each(_Function __func)",
			"    {",
			"        for (uint32 i = 0; i < _RowCount; ++i)",
			"        {",
			"            for (uint32 j = 0; j < _ColumnCount; ++j)",
			"            {",
			"                __func(i, j);",
			"            }",
			"        }",
			"    }",
			"",
			"    template<typename _ItsTp, uint32 _ItsRowCount, uint32 _ItsColumnCount>",
			"    friend class Matrix;",
			"",
			"protected:",
			"",
			"    value_type _M_matrix[_RowCount][_ColumnCount];",
			"};"
		],
		"description": "The Matrix template class"
	},

	"The manacher() function": {
		"prefix": "manacher",
		"body": [
			"int manacher(const std::string& str)",
			"{",
			"    std::string s(1, '^');",
			"    s.reserve(str.size() * 2 + 3);",
			"    ",
			"    for (int i = 0; i < str.size(); ++i)",
			"    {",
			"        s.push_back(' ');",
			"        s.push_back(str[i]);",
			"    }",
			"",
			"    s.push_back(' ');",
			"    s.push_back('$');",
			"",
			"    int c = 0, r = 0;",
			"",
			"    std::vector<int> dp(s.size());",
			"",
			"    int ans = 0;",
			"",
			"    for (int i = 1; i < s.size() - 1; ++i)",
			"    {",
			"        if (r >= i)",
			"            dp[i] = std::min(r - i, dp[c - (i - c)]);",
			"",
			"        while (s[i - dp[i] - 1] == s[i + dp[i] + 1])",
			"            ++dp[i];",
			"",
			"        if (dp[i] + i > r)",
			"        {",
			"            r = dp[i] + i;",
			"            c = i;",
			"        }",
			"",
			"        ans = std::max(ans, dp[i]);",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "The manacher() function"
	},

	"The get_z() function": {
		"prefix": "get_z",
		"body": [
			"std::vector<int> get_z(const std::string_view& s)",
			"{",
			"    std::vector<int> z(s.size());",
			"    ",
			"    z[0] = s.size();",
			"",
			"    int l = -1, r = 0;",
			"",
			"    for (int i = 1; i < s.size(); ++i)",
			"    {",
			"        if (i <= r)",
			"            z[i] = std::min(z[i - l], r - i + 1);",
			"",
			"        while (i + z[i] < s.size() and s[z[i]] == s[i + z[i]])",
			"            ++z[i];",
			"",
			"        if (i + z[i] - 1 > r)",
			"        {",
			"            r = i + z[i] - 1;",
			"            l = i;",
			"        }",
			"    }",
			"",
			"    return z;",
			"}"
		],
		"description": "The get_z() function"
	},

	"class DisjointSet: Merge by rank": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return tree[u].fa == u ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"            tree[fv].fa = fu;",
			"        else",
			"            tree[fu].fa = fv;",
			"        ",
			"        if (tree[fu].rank == tree[fv].rank)",
			"            ++tree[fv].rank;",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Merge by rank"
	},

	"class DisjointSet: Path Compression": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    std::vector<int> tree;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        std::iota(tree.begin(), tree.end(), 0);",
			"    }",
			"",
			"    int find(int u)",
			"    {",
			"        return tree[u] == u ? u : tree[u] = find(tree[u]);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        tree[find(v)] = find(u);",
			"    }",
			"};"
		],
		"description": "class DisjointSet: Path Compression"
	},

	"class DisjointSet: with Undo": {
		"prefix": "DisjointSet",
		"body": [
			"class DisjointSet",
			"{",
			"public:",
			"    struct node",
			"    {",
			"        int fa;",
			"        int rank;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    std::stack<std::pair<int&, int>, std::vector<std::pair<int&, int>>> ver_fa, ver_rank;",
			"",
			"    explicit DisjointSet(std::size_t n)",
			"        : tree(n)",
			"    {",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            tree[i].fa = i;",
			"            tree[i].rank = 1;",
			"        }",
			"    }",
			"",
			"    int find(int u) const",
			"    {",
			"        return is_root(u) ? u : find(tree[u].fa);",
			"    }",
			"",
			"    void merge(int u, int v)",
			"    {",
			"        int fu = find(u), fv = find(v);",
			"",
			"        if (tree[fu].rank > tree[fv].rank)",
			"        {",
			"            ver_fa.push({tree[fv].fa, tree[fv].fa});",
			"            tree[fv].fa = fu;",
			"        }",
			"        else",
			"        {",
			"            ver_fa.push({tree[fu].fa, tree[fu].fa});",
			"            tree[fu].fa = fv;",
			"        }",
			"        ",
			"        ver_rank.push({tree[fv].rank, tree[fv].rank});",
			"        if (tree[fu].rank == tree[fv].rank)",
			"        {",
			"            ++tree[fv].rank;",
			"        }",
			"    }",
			"",
			"    bool is_root(int u) const",
			"    {",
			"        return tree[u].fa == u;",
			"    }",
			"",
			"    bool is_same_root(int u, int v) const",
			"    {",
			"        return find(u) == find(v);",
			"    }",
			"",
			"    void undo()",
			"    {",
			"        if (not ver_fa.empty())",
			"        {",
			"            ver_fa.top().first = ver_fa.top().second;",
			"            ver_rank.top().first = ver_rank.top().second;",
			"",
			"            ver_fa.pop();",
			"            ver_rank.pop();",
			"        }",
			"    }",
			"};"
		],
		"description": "class DisjointSet: with Undo"
	},

	"Template class BinaryIndexedTree": {
		"prefix": "BinaryIndexedTree",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"// Fenwick Tree",
			"template<typename _Tp>",
			"class BinaryIndexedTree",
			"{",
			"public:",
			"",
			"    using value_type = _Tp;",
			"",
			"    constexpr BinaryIndexedTree() noexcept = default;",
			"",
			"    explicit constexpr BinaryIndexedTree(std::size_t __size) noexcept",
			"        : _M_BITree(__size + 1)",
			"    { }",
			"",
			"    [[nodiscard]] static constexpr std::size_t lowbit(std::size_t __x) noexcept",
			"    { return __x & -__x; }",
			"",
			"    constexpr void add(std::size_t __i, value_type __value = 1)",
			"    {",
			"        for (++__i; __i < _M_BITree.size(); __i += lowbit(__i))",
			"        {",
			"            _M_BITree[__i] += __value;",
			"        }",
			"    }",
			"",
			"    constexpr void subtract(std::size_t __i, value_type __value = 1)",
			"    {",
			"        for (++__i; __i < _M_BITree.size(); __i += lowbit(__i))",
			"        {",
			"            _M_BITree[__i] -= __value;",
			"        }",
			"    }",
			"",
			"    [[nodiscard]] constexpr value_type sum(std::size_t __l)",
			"    {",
			"        value_type result{};",
			"",
			"        for (++__l; __l; __l -= lowbit(__l))",
			"        {",
			"            result += _M_BITree[__l];",
			"        }",
			"",
			"        return result;",
			"    }",
			"",
			"    [[nodiscard]] constexpr value_type sum(std::size_t __l, std::size_t __r)",
			"    { return __l ? sum(__r) - sum(__l - 1) : sum(__r); }",
			"",
			"    [[nodiscard]] constexpr value_type get(std::size_t __i)",
			"    { return sum(__i, __i); }",
			"",
			"    constexpr value_type set(std::size_t __i, value_type __value)",
			"    {",
			"        value_type prev = get(__i);",
			"",
			"        prev < __value ? add(__i, __value - prev) : subtract(__i, prev - __value);",
			"",
			"        return prev;",
			"    }",
			"",
			"    constexpr void reset(std::size_t __size = static_cast<std::size_t>(-1))",
			"    { __size == static_cast<std::size_t>(-1) ? std::ranges::fill(_M_BITree, value_type{}) : _M_BITree.assign(__size + 1, value_type{}); }",
			"",
			"private:",
			"",
			"    std::vector<value_type> _M_BITree;",
			"};",
			"}"
		],
		"description": "Template class BinaryIndexedTree "
	},

	"Template class SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"template<typename _ValueType, typename _MergeFunc = std::plus<_ValueType>>",
			"class SegmentTree",
			"{",
			"public:",
			"",
			"    using value_type = _ValueType;",
			"    using reference = value_type&;",
			"    using const_reference = const value_type&;",
			"    using size_type = int;",
			"",
			"    constexpr explicit SegmentTree(size_type __n = 0)",
			"        : tree(nodes_count(__n))",
			"    { }",
			"",
			"    constexpr SegmentTree(size_type __n, _MergeFunc __merge)",
			"        : tree(nodes_count(__n)), merge(__merge)",
			"    { }",
			"",
			"    constexpr SegmentTree(size_type __n, const value_type& __value)",
			"        : SegmentTree(__n)",
			"    { set(__value); }",
			"",
			"    constexpr SegmentTree(size_type __n, const value_type& __value, _MergeFunc __merge)",
			"        : tree(nodes_count(__n)), merge(__merge)",
			"    { set(__value); }",
			"",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    constexpr SegmentTree(const _Container& __c)",
			"        : SegmentTree(static_cast<size_type>(std::size(__c)))",
			"    { build(std::begin(__c)); }",
			"",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    constexpr SegmentTree(const _Container& __c, _MergeFunc __merge)",
			"        : tree(nodes_count(static_cast<size_type>(std::size(__c)))), merge(__merge)",
			"    { build(std::begin(__c)); }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr SegmentTree(_ForwardIterator __first, _ForwardIterator __last)",
			"        : SegmentTree(static_cast<size_type>(std::distance(__first, __last)))",
			"    { build(__first, __last); }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr SegmentTree(_ForwardIterator __first, _ForwardIterator __last, _MergeFunc __merge)",
			"        : tree(nodes_count(static_cast<size_type>(std::distance(__first, __last)))), merge(__merge)",
			"    { build(__first, __last); }",
			"",
			"    [[nodiscard]] static constexpr size_type nodes_count(size_type __n) noexcept",
			"    { return __n << 2; }",
			"",
			"    [[nodiscard]] constexpr size_type nodes_count() const noexcept",
			"    { return tree.size(); }",
			"",
			"    [[nodiscard]] constexpr size_type size() const noexcept",
			"    { return static_cast<size_type>(tree.size()) >> 2; }",
			"",
			"    constexpr void resize(size_type __n)",
			"    { tree.resize(nodes_count(__n)); }",
			"",
			"    ",
			"    template<typename _Callback>",
			"    constexpr void for_each(int __l, int __r, _Callback __func)",
			"    { _M_for_each(1, 1, size(), __l + 1, __r + 1, __func); }",
			"    ",
			"    template<typename _Callback>",
			"    constexpr void for_each(_Callback __func)",
			"    { for_each(0, size() - 1, __func); }",
			"",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr void build(_ForwardIterator __first)",
			"    { build(0, size() - 1, __first); }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr void build(int __l, int __r, _ForwardIterator __first)",
			"    { for_each(__l, __r, [&](value_type& __v) -> bool { __v = *__first; ++__first; return true; }); }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr void build(_ForwardIterator __first, _ForwardIterator __last)",
			"    { build(0, __first, __last); }",
			"    ",
			"    template<typename _ForwardIterator>",
			"    constexpr void build(int __l, _ForwardIterator __first, _ForwardIterator __last)",
			"    { if (__first != __last) { for_each(__l, size() - 1, [&](value_type& __v) -> bool { __v = *__first; return ++__first != __last; }); } }",
			"",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr void flatten(_ForwardIterator __first, size_type __n = std::numeric_limits<size_type>::max())",
			"    { if (__n) { for_each(0, __n - 1, [&](const value_type& __v) -> bool { *__first = __v; ++__first; return true; }); } }",
			"    ",
			"    template<typename _ForwardIterator>",
			"    constexpr void flatten(int __l, int __r, _ForwardIterator __first)",
			"    { for_each(__l, __r, [&](const value_type& __v) -> bool { *__first = __v; ++__first; return true; }); }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr void flatten(_ForwardIterator __first, _ForwardIterator __last)",
			"    { flatten(0, __first, __last); }",
			"    ",
			"    template<typename _ForwardIterator>",
			"    constexpr void flatten(int __l, _ForwardIterator __first, _ForwardIterator __last)",
			"    { if (__first != __last) { for_each(__l, size() - 1, [&](const value_type& __v) -> bool { *__first = __v; return ++__first != __last; }); } }",
			"",
			"",
			"    [[nodiscard]] constexpr value_type reduce(int __l, int __r)",
			"    { return _M_reduce(1, 1, size(), __l + 1, __r + 1); }",
			"",
			"    [[nodiscard]] constexpr value_type reduce()",
			"    { return reduce(0, size() - 1); }",
			"",
			"    [[nodiscard]] constexpr const_reference at(int __p)",
			"    { return _M_at(1, 1, size(), __p + 1); }",
			"",
			"    [[nodiscard]] constexpr const_reference operator[](int __p)",
			"    { return at(__p); }",
			"",
			"    [[nodiscard]] constexpr value_type operator[](const std::pair<int, int>& __p)",
			"    { return reduce(__p.first, __p.second); }",
			"",
			"    template<typename _Tp = value_type>",
			"    constexpr void set(const _Tp& __value)",
			"    { set(0, size() - 1, __value); }",
			"",
			"    template<typename _Tp, typename _BinaryOperation>",
			"    constexpr void set(const _Tp& __value, _BinaryOperation __binary_op)",
			"    { set(0, size() - 1, __value, __binary_op); }",
			"    ",
			"    template<typename _Tp = value_type>",
			"    constexpr void set(int __p, const _Tp& __value)",
			"    { set(__p, __p, __value); }",
			"",
			"    template<typename _Tp, typename _BinaryOperation>",
			"    constexpr void set(int __p, const _Tp& __value, _BinaryOperation __binary_op)",
			"    { set(__p, __p, __value, __binary_op); }",
			"    ",
			"    template<typename _Tp = value_type>",
			"    constexpr void set(int __l, int __r, const _Tp& __value)",
			"    { for_each(__l, __r, [&](value_type& __v) -> bool { __v = __value; return true; }); }",
			"",
			"    template<typename _Tp, typename _BinaryOperation>",
			"    constexpr void set(int __l, int __r, const _Tp& __value, _BinaryOperation __binary_op)",
			"    { for_each(__l, __r, [&](value_type& __v) -> bool { __v = __binary_op(__v, __value); return true; }); }",
			"",
			"",
			"    constexpr void reset()",
			"    { std::fill(tree.begin(), tree.end(), value_type{}); }",
			"",
			"protected:",
			"",
			"    [[nodiscard]] static constexpr int ls(int p) noexcept",
			"    { return p << 1; }",
			"",
			"    [[nodiscard]] static constexpr int rs(int p) noexcept",
			"    { return p << 1 | 1; }",
			"",
			"    constexpr void push_up(int p)",
			"    { tree[p] = merge(tree[ls(p)], tree[rs(p)]); }",
			"",
			"    virtual void push_down(int p, int l, int r)",
			"    { }",
			"",
			"    template<typename _Callback>",
			"    constexpr bool _M_for_each(int p, int l, int r, int x, int y, _Callback&& __func)",
			"    {",
			"        if (l == r)",
			"        {",
			"            return __func(tree[p]);",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        bool continues = true;",
			"",
			"        if (x <= mid)",
			"        {",
			"            continues = _M_for_each(ls(p), l, mid, x, y, __func);",
			"        }",
			"",
			"        if (y > mid and continues)",
			"        {",
			"            continues = _M_for_each(rs(p), mid + 1, r, x, y, __func);",
			"        }",
			"",
			"        push_up(p);",
			"",
			"        return continues;",
			"    }",
			"",
			"    [[nodiscard]] constexpr value_type _M_reduce(int p, int l, int r, int x, int y)",
			"    {",
			"        if (x <= l and r <= y)",
			"        {",
			"            return tree[p];",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (x <= mid and y > mid)",
			"        {",
			"            return merge(_M_reduce(ls(p), l, mid, x, y), _M_reduce(rs(p), mid + 1, r, x, y));",
			"        }",
			"        else if (x <= mid)",
			"        {",
			"            return _M_reduce(ls(p), l, mid, x, y);",
			"        }",
			"        else",
			"        {",
			"            return _M_reduce(rs(p), mid + 1, r, x, y);",
			"        }",
			"    }",
			"",
			"    [[nodiscard]] constexpr const_reference _M_at(int p, int l, int r, int i)",
			"    {",
			"        if (l == r)",
			"        {",
			"            return tree[p];",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (i <= mid)",
			"        {",
			"            return _M_at(ls(p), l, mid, i);",
			"        }",
			"        else",
			"        {",
			"            return _M_at(rs(p), mid + 1, r, i);",
			"        }",
			"    }",
			"",
			"    std::vector<value_type> tree;",
			"    _MergeFunc merge{};",
			"};",
			"",
			"template<typename _Container>",
			"SegmentTree(const _Container&) -> SegmentTree<typename _Container::value_type>;",
			"",
			"template<typename _Container, typename _MergeFunc>",
			"SegmentTree(const _Container&, _MergeFunc) -> SegmentTree<typename _Container::value_type, _MergeFunc>;",
			"",
			"template<typename _ForwardIterator>",
			"SegmentTree(_ForwardIterator, _ForwardIterator) -> SegmentTree<decltype(*std::declval<_ForwardIterator>())>;",
			"",
			"template<typename _ForwardIterator, typename _MergeFunc>",
			"SegmentTree(_ForwardIterator, _ForwardIterator, _MergeFunc) -> SegmentTree<decltype(*std::declval<_ForwardIterator>()), _MergeFunc>;",
			"}"
		],
		"description": "Template class SegmentTree"
	},

	"Template class LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"struct MakeLazyFunc",
			"{",
			"    struct Add",
			"    {",
			"        constexpr void operator()(const auto& that, const auto& value) noexcept",
			"        {",
			"            that.value += value;",
			"            that.lazy  += value;",
			"        }",
			"    };",
			"",
			"    struct RangeAdd",
			"    {",
			"        constexpr void operator()(const auto& that, const auto& value) noexcept",
			"        {",
			"            that.value += value * that.size;",
			"            that.lazy  += value;",
			"        }",
			"    };",
			"",
			"    struct Assign",
			"    {",
			"        constexpr void operator()(const auto& that, const auto& value) noexcept",
			"        {",
			"            that.value = value;",
			"            that.lazy  = value;",
			"        }",
			"    };",
			"",
			"    struct Merge",
			"    {",
			"        constexpr void operator()(const auto& that, const auto& value) noexcept",
			"        {",
			"            that.value = that.merge(that.value, value);",
			"",
			"            if (that.marked)",
			"                that.lazy = that.merge(that.lazy, value);",
			"            else",
			"                that.lazy = value;",
			"        }",
			"    };",
			"};",
			"",
			"template<",
			"    typename _ValueType, typename _MergeFunc = std::plus<_ValueType>,",
			"    typename _LazyType = _ValueType, typename _MakeLazyFunc = MakeLazyFunc::RangeAdd>",
			"class LazySegmentTree : public SegmentTree<_ValueType, _MergeFunc>",
			"{",
			"public:",
			"",
			"    using parent_type = SegmentTree<_ValueType, _MergeFunc>;",
			"",
			"    using value_type = parent_type::value_type;",
			"    using size_type  = parent_type::size_type;",
			"",
			"    using lazy_type  = _LazyType;",
			"",
			"    using parent_type::size;",
			"    ",
			"    struct lazy_build_info",
			"    {",
			"        value_type& value;",
			"        lazy_type&  lazy;",
			"        _MergeFunc& merge;",
			"",
			"        size_type size;",
			"        bool marked;",
			"    };",
			"",
			"private:",
			"",
			"    using parent_type::ls;",
			"    using parent_type::rs;",
			"",
			"    using parent_type::push_up;",
			"",
			"    using parent_type::tree;",
			"    using parent_type::merge;",
			"",
			"public:",
			"    ",
			"    constexpr explicit LazySegmentTree(size_type __n = 0)",
			"        : parent_type(__n), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"",
			"    constexpr LazySegmentTree(size_type __n, _MergeFunc __merge)",
			"        : parent_type(__n, __merge), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"",
			"    constexpr LazySegmentTree(size_type __n, _MergeFunc __merge, _MakeLazyFunc __makelazy)",
			"        : parent_type(__n, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
			"    { }",
			"",
			"    constexpr LazySegmentTree(size_type __n, const value_type& __value)",
			"        : parent_type(__n, __value), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"",
			"    constexpr LazySegmentTree(size_type __n, const value_type& __value, _MergeFunc __merge)",
			"        : parent_type(__n, __value, __merge), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"    ",
			"    constexpr LazySegmentTree(size_type __n, const value_type& __value, _MergeFunc __merge, _MakeLazyFunc __makelazy)",
			"        : parent_type(__n, __value, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
			"    { }",
			"",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    constexpr LazySegmentTree(const _Container& __c)",
			"        : parent_type(__c), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    constexpr LazySegmentTree(const _Container& __c, _MergeFunc __merge)",
			"        : parent_type(__c, __merge), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"    ",
			"    template<typename _Container, typename = std::void_t<decltype(std::declval<_Container>().size()), decltype(std::declval<_Container>().begin())>>",
			"    constexpr LazySegmentTree(const _Container& __c, _MergeFunc __merge, _MakeLazyFunc __makelazy)",
			"        : parent_type(__c, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
			"    { }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr LazySegmentTree(_ForwardIterator __first, _ForwardIterator __last)",
			"        : parent_type(__first, __last), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"",
			"    template<typename _ForwardIterator>",
			"    constexpr LazySegmentTree(_ForwardIterator __first, _ForwardIterator __last, _MergeFunc __merge)",
			"        : parent_type(__first, __last, __merge), lazy(tree.size()), marked(tree.size())",
			"    { }",
			"    ",
			"    template<typename _ForwardIterator>",
			"    constexpr LazySegmentTree(_ForwardIterator __first, _ForwardIterator __last, _MergeFunc __merge, _MakeLazyFunc __makelazy)",
			"        : parent_type(__first, __last, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
			"    { }",
			"    ",
			"    constexpr void range_update(int __l, int __r, const lazy_type& __value)",
			"    { _M_range_update(1, 1, size(), __l + 1, __r + 1, __value); }",
			"    ",
			"    constexpr void resize(size_type __n)",
			"    {",
			"        parent_type::resize(__n);",
			"        lazy.resize(parent_type::nodes_count(__n));",
			"        marked.resize(parent_type::nodes_count(__n));",
			"    }",
			"",
			"    constexpr void reset()",
			"    {",
			"        parent_type::reset();",
			"        std::fill(lazy.begin(), lazy.end(), lazy_type{});",
			"        marked.assign(marked.size(), false);",
			"    }",
			"",
			"protected:",
			"",
			"    void make_lazy(int p, int l, int r, const lazy_type& value)",
			"    {",
			"        make_lazy_func(lazy_build_info{",
			"            .value  = tree[p],",
			"            .lazy   = lazy[p],",
			"            .merge  = merge,",
			"            .size   = r - l + 1,",
			"            .marked = marked[p]",
			"        }, value);",
			"",
			"        marked[p] = true;",
			"    }",
			"",
			"    void push_down(int p, int l, int r) override",
			"    {",
			"        if (marked[p])",
			"        {",
			"            int mid = (l + r) >> 1;",
			"",
			"            make_lazy(ls(p), l, mid, lazy[p]);",
			"            make_lazy(rs(p), mid + 1, r, lazy[p]);",
			"            ",
			"            lazy[p] = lazy_type{};",
			"            marked[p] = false;",
			"        }",
			"    }",
			"",
			"    void _M_range_update(int p, int l, int r, int x, int y, const lazy_type& v)",
			"    {",
			"        if (x <= l and r <= y)",
			"        {",
			"            make_lazy(p, l, r, v);",
			"            return;",
			"        }",
			"",
			"        push_down(p, l, r);",
			"",
			"        int mid = (l + r) >> 1;",
			"",
			"        if (x <= mid)",
			"        {",
			"            _M_range_update(ls(p), l, mid, x, y, v);",
			"        }",
			"",
			"        if (y > mid)",
			"        {",
			"            _M_range_update(rs(p), mid + 1, r, x, y, v);",
			"        }",
			"        ",
			"        push_up(p);",
			"    }",
			"",
			"protected:",
			"",
			"    std::vector<lazy_type> lazy;",
			"    std::vector<bool> marked;",
			"",
			"    _MakeLazyFunc make_lazy_func;",
			"};",
			"",
			"template<typename _ValueType, typename _MergeFunc, typename _MakeLazyFunc>",
			"LazySegmentTree(typename LazySegmentTree<_ValueType, _MergeFunc, _ValueType, _MakeLazyFunc>::size_type, const _ValueType&, _MergeFunc, _MakeLazyFunc) -> LazySegmentTree<_ValueType, _MergeFunc, _ValueType, _MakeLazyFunc>;",
			"",
			"template<typename _Container>",
			"LazySegmentTree(const _Container&) -> LazySegmentTree<typename _Container::value_type>;",
			"",
			"template<typename _Container, typename _MergeFunc>",
			"LazySegmentTree(const _Container&, _MergeFunc) -> LazySegmentTree<typename _Container::value_type, _MergeFunc>;",
			"",
			"template<typename _Container, typename _MergeFunc, typename _MakeLazyFunc>",
			"LazySegmentTree(const _Container&, _MergeFunc, _MakeLazyFunc) -> LazySegmentTree<typename _Container::value_type, _MergeFunc, typename _Container::value_type, _MakeLazyFunc>;",
			"",
			"template<typename _ForwardIterator>",
			"LazySegmentTree(_ForwardIterator, _ForwardIterator) -> LazySegmentTree<decltype(*std::declval<_ForwardIterator>())>;",
			"",
			"template<typename _ForwardIterator, typename _MergeFunc>",
			"LazySegmentTree(_ForwardIterator, _ForwardIterator, _MergeFunc) -> LazySegmentTree<decltype(*std::declval<_ForwardIterator>()), _MergeFunc>;",
			"",
			"template<typename _ForwardIterator, typename _MergeFunc, typename _MakeLazyFunc>",
			"LazySegmentTree(_ForwardIterator, _ForwardIterator, _MergeFunc, _MakeLazyFunc) -> LazySegmentTree<decltype(*std::declval<_ForwardIterator>()), _MergeFunc, decltype(*std::declval<_ForwardIterator>()), _MakeLazyFunc>;",
			"}"
		],
		"description": "Template class LazySegmentTree"
	},

	"Template class ScapegoatTree": {
		"prefix": "ScapegoatTree",
		"body": [
			"template<typename _ValueType, typename _Compare = std::less<_ValueType>>",
			"class ScapegoatTree",
			"{",
			"public:",
			"",
			"    using value_type = _ValueType;",
			"    using value_comp = _Compare;",
			"",
			"    struct node",
			"    {",
			"        int ls, rs;",
			"        int size;",
			"        int removed_size;",
			"",
			"        bool is_removed;",
			"",
			"        value_type value;",
			"    };",
			"",
			"    static constexpr const double alpha = 0.75;",
			"",
			"    explicit ScapegoatTree()",
			"        : tree(1) { }",
			"",
			"    int& root() const noexcept { return rootNode; }",
			"",
			"    int size() const noexcept",
			"    {",
			"        return tree[root()].size;",
			"    }",
			"",
			"    bool empty() const noexcept",
			"    {",
			"        return not(size());",
			"    }",
			"",
			"    const value_type& front() const noexcept",
			"    {",
			"        return (*this)[0];",
			"    }",
			"",
			"    const value_type& back() const noexcept",
			"    {",
			"        return (*this)[size() - 1];",
			"    }",
			"",
			"    bool check(int p) const",
			"    {",
			"        return std::max(tree[tree[p].ls].size, tree[tree[p].rs].size) > tree[p].size * alpha;",
			"    }",
			"",
			"    bool check_removed(int p) const",
			"    {",
			"        return std::max(",
			"            tree[tree[p].ls].removed_size + tree[tree[p].ls].size,",
			"            tree[tree[p].rs].removed_size + tree[tree[p].rs].size)",
			"                > (tree[p].removed_size + tree[p].size) * alpha;",
			"    }",
			"",
			"    void build(int& u, int l, int r, const std::vector<value_type>& que)",
			"    {",
			"        if (l == r) return;",
			"",
			"        int mid = l + r >> 1;",
			"",
			"        if (u == 0)",
			"        {",
			"            u = push_node();",
			"            tree[u].size = 1;",
			"        }",
			"        tree[u].value = que[mid];",
			"",
			"        build(tree[u].ls, l, mid, que);",
			"        build(tree[u].rs, mid + 1, r, que);",
			"",
			"        tree[u].size = tree[tree[u].ls].size + tree[tree[u].rs].size + 1;",
			"        return;",
			"    }",
			"",
			"    void rebuild(int p)",
			"    {",
			"        std::vector<value_type> que(1);",
			"        que.reserve(tree[p].size + 1);",
			"",
			"        inorder(p, p, que);",
			"",
			"        tree[p] = node();",
			"        build(p, 1, que.size(), que);",
			"",
			"        return;",
			"    }",
			"",
			"    void insert(const value_type& value)",
			"    {",
			"        int rb = 0;",
			"        std::function<void(int&)> func = [&](int& u) -> void",
			"        {",
			"            if (u == 0)",
			"            {",
			"                u = push_node();",
			"                tree[u].value = value;",
			"                tree[u].size = 1;",
			"                return;",
			"            }",
			"",
			"            ++tree[u].size;",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                func(tree[u].ls);",
			"            else",
			"                func(tree[u].rs);",
			"",
			"            if (check(u))",
			"                rb = u;",
			"        };",
			"        if (recycle.empty() && tree.capacity() < tree.size() + 1)",
			"            tree.reserve(std::size_t(double(tree.size() + 1) * 1.5));",
			"",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"    }",
			"",
			"    bool erase(const value_type& value)",
			"    {",
			"        int rb = 0, rbr = 0;",
			"        std::function<bool(int)> func = [&](int u) -> bool",
			"        {",
			"            if (u == 0)",
			"            {",
			"                return false;",
			"            }",
			"",
			"            if (tree[u].is_removed == false",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                tree[u].is_removed = true;",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                return true;",
			"            }",
			"",
			"            bool ans = false;",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                ans |= func(tree[u].ls);",
			"            else",
			"                ans |= func(tree[u].rs);",
			"",
			"            if (ans)",
			"            {",
			"                ++tree[u].removed_size;",
			"                --tree[u].size;",
			"                if (check_removed(u))",
			"                {",
			"                    rb = u;",
			"                    rbr = tree[u].removed_size;",
			"                }",
			"                tree[u].removed_size -= rbr;",
			"            }",
			"            return ans;",
			"        };",
			"",
			"        bool ans = func(root());",
			"        if (rb) rebuild(rb);",
			"",
			"        return ans;",
			"    }",
			"",
			"    bool erase_at(int index)",
			"    {",
			"        if (index >= size()) return false;",
			"        int rb = 0, rbr = 0;",
			"        std::function<void(int)> func = [&](int u) -> void",
			"        {",
			"            if (u == 0) return;",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"            {",
			"                tree[u].is_removed = true;",
			"                --tree[u].size;",
			"                ++tree[u].removed_size;",
			"                return;",
			"            }",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                func(tree[u].ls);",
			"            else",
			"                index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"",
			"            ++tree[u].removed_size;",
			"            --tree[u].size;",
			"            if (check_removed(u))",
			"            {",
			"                rb = u;",
			"                rbr = tree[u].removed_size;",
			"            }",
			"            tree[u].removed_size -= rbr;",
			"        };",
			"        func(root());",
			"",
			"        if (rb) rebuild(rb);",
			"        return true;",
			"    }",
			"",
			"    int count(const value_type& value) const",
			"    {",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            bool equal = not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value);",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls) + equal;",
			"            else",
			"                return func(tree[u].rs) + equal;",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"    int indexof(const value_type& value, bool* const exist = nullptr) const",
			"    {",
			"        bool _exist = false;",
			"        std::function<int(int)> func = [&](int u) -> int",
			"        {",
			"            if (u == 0) return 0;",
			"",
			"            if (not _exist",
			"                and not tree[u].is_removed",
			"                and not value_comp()(value, tree[u].value)",
			"                and not value_comp()(tree[u].value, value))",
			"            {",
			"                _exist = true;",
			"            }",
			"",
			"            if (not(value_comp()(tree[u].value, value)))",
			"                return func(tree[u].ls);",
			"            else",
			"                return func(tree[u].rs) + tree[tree[u].ls].size + !tree[u].is_removed;",
			"        };",
			"        if (exist) *exist = _exist;",
			"        return func(root());",
			"    }",
			"",
			"    const value_type& operator[](int index) const",
			"    {",
			"        std::function<const value_type& (int)> func = [&](int u) -> const value_type&",
			"        {",
			"            if (u == 0)",
			"                return value_type();",
			"",
			"            if (index == tree[tree[u].ls].size and not tree[u].is_removed)",
			"                return tree[u].value;",
			"",
			"            if (index < tree[tree[u].ls].size)",
			"                return func(tree[u].ls);",
			"            else",
			"                return index -= tree[tree[u].ls].size + !tree[u].is_removed, func(tree[u].rs);",
			"        };",
			"        return func(root());",
			"    }",
			"",
			"protected:",
			"    int push_node()",
			"    {",
			"        if (recycle.size())",
			"        {",
			"            int top = recycle.back();",
			"            recycle.pop_back();",
			"            tree[top] = node();",
			"            return top;",
			"        }",
			"        else",
			"        {",
			"            tree.push_back(node());",
			"            return tree.size() - 1;",
			"        }",
			"    }",
			"",
			"    void inorder(int p, int np, std::vector<value_type>& que)",
			"    {",
			"        if (p == 0) return;",
			"",
			"        inorder(tree[p].ls, np, que);",
			"",
			"        if (tree[p].is_removed == false)",
			"            que.push_back(tree[p].value);",
			"",
			"        if (p != np)",
			"            recycle.push_back(p);",
			"",
			"        inorder(tree[p].rs, np, que);",
			"",
			"        return;",
			"    }",
			"",
			"private:",
			"    std::vector<node> tree;",
			"    std::vector<int>  recycle;",
			"",
			"    mutable int rootNode = 0;",
			"};"
		],
		"description": "Template class ScapegoatTree"
	},

	"Template class Hash": {
		"prefix": "Hash",
		"body": [
			"inline namespace huanhuanonly {",
			"    inline namespace hashing",
			"{",
			"using hash_result_type = uint64;",
			"",
			"constexpr hash_result_type hash_base = std::array{449, 100003, 1000003, 1000000007}[0];",
			"constexpr hash_result_type hash_mod  = std::array{998244353ULL, 4294967291ULL}[0];",
			"",
			"static_assert(hash_base < hash_mod);",
			"static_assert(hash_mod <= std::numeric_limits<hash_result_type>::max() / hash_mod);",
			"",
			"template<typename _Tp>",
			"struct Hash : std::hash<_Tp>",
			"{ using value_type = _Tp; };",
			"",
			"template<std::integral _Tp>",
			"struct Hash<_Tp>",
			"{",
			"    using value_type = _Tp;",
			"",
			"    [[nodiscard]] static constexpr",
			"    hash_result_type",
			"    splitmix64(hash_result_type __value) noexcept",
			"    {",
			"        __value += 0x9e3779b97f4a7c15;",
			"        __value = (__value ^ (__value >> 30)) * 0xbf58476d1ce4e5b9;",
			"        __value = (__value ^ (__value >> 27)) * 0x94d049bb133111eb;",
			"        return __value ^ (__value >> 31);",
			"    }",
			"",
			"    [[nodiscard]]",
			"    hash_result_type",
			"    operator()(value_type __value) const noexcept",
			"    {",
			"        static const hash_result_type fixed_random =",
			"            std::chrono::steady_clock::now().time_since_epoch().count();",
			"",
			"        return splitmix64(fixed_random + __value);",
			"    }",
			"};",
			"",
			"template<typename _Ft, typename _St>",
			"struct Hash<std::pair<_Ft, _St>>",
			"{",
			"    using value_type = std::pair<_Ft, _St>;",
			"",
			"    [[nodiscard]] constexpr",
			"    hash_result_type",
			"    operator()(const value_type& __value) const noexcept",
			"    {",
			"        return (Hash<_Ft>{}(__value.first) % hash_mod * hash_base % hash_mod + Hash<_St>{}(__value.second) % hash_mod) % hash_mod;",
			"    }",
			"};",
			"",
			"template<typename... _Args>",
			"struct Hash<std::tuple<_Args...>>",
			"{",
			"    using value_type = std::tuple<_Args...>;",
			"",
			"    [[nodiscard]] constexpr",
			"    hash_result_type",
			"    operator()(const value_type& __value) const noexcept",
			"    {",
			"        return std::apply([](auto&&... args) -> hash_result_type",
			"        {",
			"            hash_result_type result = 0;",
			"",
			"            for (const hash_result_type& i : std::array{{Hash<_Args...>{}(args)...}})",
			"            {",
			"                result *= hash_base;",
			"                result %= hash_mod;",
			"                result += i % hash_mod;",
			"                result %= hash_mod;",
			"            }",
			"",
			"            return result;",
			"        }, __value);",
			"    }",
			"};",
			"",
			"template<std::ranges::input_range _Tp>",
			"struct Hash<_Tp>",
			"{",
			"    using value_type = _Tp;",
			"",
			"    [[nodiscard]] constexpr",
			"    hash_result_type",
			"    operator()(const value_type& __value) const noexcept",
			"    {",
			"        hash_result_type result = 0;",
			"",
			"        auto begin = std::ranges::begin(__value);",
			"        auto end   = std::ranges::end(__value);",
			"",
			"        if constexpr (",
			"            std::is_array_v<std::remove_reference_t<value_type>> and",
			"            std::is_same_v<std::remove_extent_t<std::remove_reference_t<value_type>>, char>)",
			"        {",
			"            --end;",
			"        }",
			"",
			"        for (; begin != end; ++begin)",
			"        {",
			"            const auto& i = *begin;",
			"",
			"            result *= hash_base;",
			"            result %= hash_mod;",
			"",
			"            if constexpr (requires{ value_type::value_type; })",
			"            {",
			"                result += Hash<typename _Tp::value_type>{}(i) % hash_mod;",
			"            }",
			"            else",
			"            {",
			"                result += Hash<std::remove_reference_t<decltype(i)>>{}(i) % hash_mod;",
			"            }",
			"",
			"            result %= hash_mod;",
			"        }",
			"",
			"        return result;",
			"    }",
			"};",
			"",
			"template<>",
			"struct Hash<void>",
			"{",
			"    template<typename _Tp>",
			"    [[nodiscard]] constexpr",
			"    hash_result_type",
			"    operator()(const _Tp& __value) const noexcept",
			"    {",
			"        return Hash<_Tp>{}(__value);",
			"    }",
			"};",
			"",
			"class RangeHash",
			"{",
			"public:",
			"",
			"    using container_type = std::vector<std::pair<hash_result_type, hash_result_type>>;",
			"    using size_type = std::size_t;",
			"",
			"    static constexpr auto npos = static_cast<size_type>(-1);",
			"",
			"    RangeHash() noexcept",
			"        : _M_c{{0, 1}}",
			"    { };",
			"",
			"    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent>",
			"    RangeHash(_Iter __first, _Sent __last)",
			"        : RangeHash()",
			"    { append(__first, __last); }",
			"",
			"    template<std::ranges::input_range _Range>",
			"    RangeHash(_Range&& __r)",
			"        : RangeHash()",
			"    { append(std::forward<_Range>(__r)); }",
			"",
			"    template<typename _Tp>",
			"    void",
			"    push_back(const _Tp& __value)",
			"    {",
			"        _M_c.emplace_back(",
			"            (_M_c.back().first * hash_base % hash_mod + Hash<void>{}(__value) % hash_mod) % hash_mod,",
			"            _M_c.back().second * hash_base % hash_mod);",
			"    }",
			"",
			"    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent>",
			"    void",
			"    append(_Iter __first, _Sent __last)",
			"    {",
			"        if constexpr (",
			"            std::sized_sentinel_for<_Sent, _Iter> and",
			"            requires(container_type c) { c.reserve(std::size_t{}); })",
			"        {",
			"            _M_c.reserve(_M_c.size() + static_cast<std::size_t>(std::ranges::distance(__first, __last)));",
			"        }",
			"",
			"        for (; __first != __last; ++__first)",
			"        {",
			"            push_back(*__first);",
			"        }",
			"    }",
			"",
			"    template<std::ranges::input_range _Range>",
			"    void",
			"    append(_Range&& __r)",
			"    { append(std::ranges::begin(__r), std::ranges::end(__r)); }",
			"",
			"    void",
			"    pop_back(size_type __n = 1)",
			"    { _M_c.resize(_M_c.size() - std::min(__n, _M_c.size() - 1)); }",
			"",
			"    [[nodiscard]] size_type",
			"    size() const noexcept",
			"    { return _M_c.size() - 1; }",
			"",
			"    [[nodiscard]] bool",
			"    empty() const noexcept",
			"    { return size() == 0; }",
			"",
			"    [[nodiscard]] hash_result_type",
			"    operator()() const noexcept",
			"    { return _M_c.back().first; }",
			"",
			"    [[nodiscard]] hash_result_type",
			"    operator()(size_type __pos, size_type __n) const noexcept",
			"    {",
			"        if (__pos >= size())",
			"        {",
			"            return 0;",
			"        }",
			"",
			"        if (__pos + __n >= _M_c.size())",
			"        {",
			"            __n = _M_c.size() - __pos - 1;",
			"        }",
			"",
			"        return (_M_c[__pos + __n].first + hash_mod - _M_c[__pos].first * _M_c[__n].second % hash_mod) % hash_mod;",
			"    }",
			"",
			"    [[nodiscard]] hash_result_type",
			"    operator[](size_type __i) const noexcept",
			"    { return (*this)(__i, __i); }",
			"",
			"    [[nodiscard]] hash_result_type",
			"    front(size_type __n = 1) const noexcept",
			"    { return _M_c[std::min(__n, size())].first; }",
			"",
			"    [[nodiscard]] hash_result_type",
			"    back(size_type __n = 1) const noexcept",
			"    { return empty() ? 0 : (*this)(size() - std::min(__n, size()), std::min(__n, size())); }",
			"",
			"    [[nodiscard]] bool",
			"    operator==(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() == __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    operator!=(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() != __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    operator<(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() < __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    operator<=(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() <= __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    operator>(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() > __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    operator>=(const RangeHash& __rhs) const noexcept",
			"    { return (*this)() >= __rhs(); }",
			"",
			"    [[nodiscard]] bool",
			"    matches(const RangeHash& __h, size_type __pos) const noexcept",
			"    { return (*this)(__pos, __h.size()) == __h(); }",
			"",
			"    [[nodiscard]] bool",
			"    starts_with(const RangeHash& __h) const noexcept",
			"    { return matches(__h, 0); }",
			"",
			"    [[nodiscard]] bool",
			"    ends_with(const RangeHash& __h) const noexcept",
			"    { return matches(__h, size() - std::min(__h.size(), size())); }",
			"",
			"    [[nodiscard]] size_type",
			"    find(const RangeHash& __h, size_type __pos = 0) const noexcept",
			"    {",
			"        const auto n1 = size(), n2 = __h.size();",
			"",
			"        for (; __pos + n2 <= n1; ++__pos)",
			"        {",
			"            if (matches(__h, __pos))",
			"            {",
			"                return __pos;",
			"            }",
			"        }",
			"",
			"        return npos;",
			"    }",
			"",
			"    [[nodiscard]] size_type",
			"    rfind(const RangeHash& __h, size_type __pos = std::numeric_limits<size_type>::max()) const noexcept",
			"    {",
			"        const auto n1 = size(), n2 = __h.size();",
			"",
			"        if (__pos >= size())",
			"        {",
			"            __pos = size();",
			"        }",
			"        else",
			"        {",
			"            ++__pos;",
			"        }",
			"",
			"        while (__pos--)",
			"        {",
			"            if (matches(__h, __pos))",
			"            {",
			"                return __pos;",
			"            }",
			"        }",
			"",
			"        return npos;",
			"    }",
			"",
			"    [[nodiscard]] bool",
			"    contains(const RangeHash& __h) const noexcept",
			"    { return find(__h) != npos; }",
			"",
			"    enum OverlapMode",
			"    {",
			"        AllowOverlap,",
			"        NoOverlap",
			"    };",
			"",
			"    [[nodiscard]] size_type",
			"    count(const RangeHash& __h, OverlapMode __mode = AllowOverlap) const noexcept",
			"    {",
			"        if (__h.size() == 0)",
			"        {",
			"            return 0;",
			"        }",
			"",
			"        size_type cnt = 0;",
			"",
			"        if (__mode == AllowOverlap)",
			"        {",
			"            for (size_type pos = find(__h); pos != npos; ++cnt, pos = find(__h, pos + 1));",
			"        }",
			"        else",
			"        {",
			"            for (size_type pos = find(__h); pos != npos; ++cnt, pos = find(__h, pos + __h.size()));",
			"        }",
			"",
			"        return cnt;",
			"    }",
			"",
			"    [[nodiscard]] size_type",
			"    longest_suffix_prefix_overlap(const RangeHash& __h) const noexcept",
			"    {",
			"        for (size_type i = std::min(size(), __h.size()); i > 0; --i)",
			"        {",
			"            if (back(i) == __h.front(i))",
			"            {",
			"                return i;",
			"            }",
			"        }",
			"",
			"        return 0;",
			"    }",
			"",
			"private:",
			"",
			"    container_type _M_c;",
			"};",
			"}}"
		],
		"description": "Template class Hash"
	},

	"Template class StaticModular": {
		"prefix": "StaticModular",
		"body": [
			"inline namespace huanhuanonly",
			"{",
			"template<typename _Tp, _Tp _Modulus>",
			"class StaticModular",
			"{",
			"public:",
			"",
			"    using value_type = _Tp;",
			"    using reference = _Tp&;",
			"    using const_reference = const _Tp&;",
			"",
			"    constexpr StaticModular(value_type __value = {}) noexcept",
			"        : _M_value(residue(__value))",
			"    { }",
			"",
			"    constexpr value_type value() const noexcept",
			"    { return _M_value; }",
			"",
			"    static constexpr value_type modulus() noexcept",
			"    { return _Modulus; }",
			"",
			"    template<typename _Ty>",
			"    static constexpr _Ty residue(_Ty __x) noexcept",
			"    {",
			"        if constexpr (std::is_unsigned_v<_Ty>)",
			"        {",
			"            return __x % modulus();",
			"        }",
			"        else",
			"        {",
			"            return (__x % modulus() + modulus()) % modulus();",
			"        }",
			"    }",
			"",
			"    template<typename _Ty>",
			"    constexpr StaticModular power(_Ty __x) const noexcept",
			"    {",
			"        StaticModular result(static_cast<value_type>(1));",
			"        auto t = *this;",
			"",
			"        for (; __x; t *= t, __x >>= 1)",
			"        {",
			"            (__x & 1) ? void(result *= t) : void();",
			"        }",
			"",
			"        return result;",
			"    }",
			"",
			"    constexpr StaticModular inverse() const noexcept",
			"    {",
			"        if constexpr (std::is_integral_v<value_type>)",
			"        {",
			"            assert(std::gcd(_M_value, modulus()) == 1);",
			"        }",
			"",
			"        auto extended_euclid = [&](const auto& self, auto a, decltype(a) b) -> std::array<decltype(a), 2>",
			"        {",
			"            if (b == 0)",
			"            {",
			"                return {1, 0};",
			"            }",
			"",
			"            auto [x, y] = self(self, b, a % b);",
			"            return {{y, x - a / b * y}};",
			"        };",
			"",
			"        if constexpr (std::is_signed_v<value_type>)",
			"        {",
			"            return static_cast<value_type>(residue(extended_euclid(extended_euclid, _M_value, modulus())[0]));",
			"        }",
			"        else if constexpr (std::is_unsigned_v<value_type>)",
			"        {",
			"            return static_cast<value_type>(residue(extended_euclid(extended_euclid, std::make_signed_t<value_type>(_M_value), std::make_signed_t<value_type>(modulus()))[0]));",
			"        }",
			"        else",
			"        {",
			"            return static_cast<value_type>(residue(extended_euclid(extended_euclid, __int128_t(_M_value), __int128_t(modulus()))[0]));",
			"        }",
			"    }",
			"",
			"    template<typename _Ty>",
			"    constexpr _Ty cast() const noexcept",
			"    { return static_cast<_Ty>(_M_value); }",
			"",
			"",
			"    constexpr StaticModular& operator=(value_type __value) noexcept",
			"    { _M_value = residue(__value); return *this; }",
			"",
			"    constexpr operator value_type() const noexcept",
			"    { return _M_value; }",
			"",
			"    constexpr std::strong_ordering operator<=>(value_type __x) const noexcept",
			"    { return _M_value <=> __x; }",
			"",
			"    constexpr std::strong_ordering operator<=>(StaticModular __other) const noexcept",
			"    { return _M_value <=> __other._M_value; }",
			"",
			"    constexpr reference operator*() noexcept",
			"    { return _M_value; }",
			"    ",
			"    constexpr const_reference operator*() const noexcept",
			"    { return _M_value; }",
			"",
			"    constexpr bool operator!() const noexcept",
			"    { return !_M_value; }",
			"",
			"    constexpr StaticModular operator~() const noexcept",
			"    { return ~_M_value; }",
			"",
			"    constexpr StaticModular operator+() const noexcept",
			"    { return +_M_value; }",
			"",
			"    constexpr StaticModular operator-() const noexcept",
			"    { return -_M_value; }",
			"",
			"    constexpr StaticModular& operator++() noexcept",
			"    { _M_value = residue(++_M_value); return *this; }",
			"",
			"    constexpr StaticModular& operator--() noexcept",
			"    { _M_value -= 1; return *this; }",
			"",
			"    constexpr StaticModular operator++(int) noexcept",
			"    { auto t = *this; ++*this; return t; }",
			"",
			"    constexpr StaticModular operator--(int) noexcept",
			"    { auto t = *this; --*this; return t; }",
			"",
			"    constexpr StaticModular operator+(value_type __x) const noexcept",
			"    { return _M_value + residue(__x); }",
			"",
			"    constexpr StaticModular operator-(value_type __x) const noexcept",
			"    { return _M_value + modulus() - residue(__x); }",
			"    ",
			"    constexpr StaticModular operator*(value_type __x) const noexcept",
			"    { auto t = *this; t *= __x; return t; }",
			"",
			"    constexpr StaticModular operator/(value_type __x) const noexcept",
			"    { return *this * StaticModular(__x).inverse(); }",
			"",
			"    constexpr StaticModular operator%(value_type __x) const noexcept",
			"    { return _M_value % __x; }",
			"",
			"    constexpr StaticModular& operator+=(value_type __x) noexcept",
			"    { return *this = *this + __x; }",
			"    ",
			"    constexpr StaticModular& operator-=(value_type __x) noexcept",
			"    { return *this = *this - __x; }",
			"",
			"    constexpr StaticModular& operator*=(value_type __x) noexcept",
			"    {",
			"        if constexpr (std::numeric_limits<value_type>::max() / modulus() >= modulus())",
			"        {",
			"            _M_value = residue(_M_value * residue(__x));",
			"            return *this;",
			"        }",
			"#ifdef __GNUC__",
			"        else if constexpr (sizeof(value_type) <= 8U)",
			"        {",
			"            _M_value = static_cast<value_type>(residue(static_cast<__uint128_t>(_M_value) * residue(__x)));",
			"            return *this;",
			"        }",
			"#endif",
			"        else",
			"        {",
			"            __x = residue(__x);",
			"    ",
			"            StaticModular result;",
			"    ",
			"            for (; __x; *this += *this, __x >>= 1)",
			"            {",
			"                (__x & 1) ? void(result += *this) : void();",
			"            }",
			"    ",
			"            return *this = result;",
			"        }",
			"    }",
			"",
			"    constexpr StaticModular& operator/=(value_type __x) noexcept",
			"    { return *this = *this / __x; }",
			"",
			"    constexpr StaticModular& operator%=(value_type __x) noexcept",
			"    { return *this = *this % __x; }",
			"",
			"    constexpr StaticModular operator<<(value_type __x) const noexcept",
			"    { return *this * StaticModular(2).power(__x); }",
			"",
			"    constexpr StaticModular operator>>(value_type __x) const noexcept",
			"    { return *this / StaticModular(2).power(__x); }",
			"",
			"    constexpr StaticModular& operator<<=(value_type __x) noexcept",
			"    { return *this *= StaticModular(2).power(__x); }",
			"",
			"    constexpr StaticModular& operator>>=(value_type __x) noexcept",
			"    { return *this /= StaticModular(2).power(__x); }",
			"",
			"    constexpr StaticModular operator^(value_type __x) const noexcept",
			"    { return _M_value ^ __x; }",
			"",
			"    constexpr StaticModular operator&(value_type __x) const noexcept",
			"    { return _M_value & __x; }",
			"",
			"    constexpr StaticModular operator|(value_type __x) const noexcept",
			"    { return _M_value | __x; }",
			"",
			"    constexpr StaticModular& operator^=(value_type __x) noexcept",
			"    { return *this = *this ^ __x; }",
			"",
			"    constexpr StaticModular& operator&=(value_type __x) noexcept",
			"    { return *this = *this & __x; }",
			"",
			"    constexpr StaticModular& operator|=(value_type __x) noexcept",
			"    { return *this = *this | __x; }",
			"",
			"    friend inline std::istream& operator>>(std::istream& __is, StaticModular& __that) noexcept",
			"    { auto& result = __is >> __that._M_value; __that._M_value = __that.residue(__that._M_value); return result; }",
			"",
			"    friend inline std::ostream& operator<<(std::ostream& __os, const StaticModular& __that) noexcept",
			"    { return __os << __that._M_value; }",
			"",
			"private:",
			"",
			"    value_type _M_value;",
			"};",
			"}"
		],
		"description": "Template class StaticModular"
	},

	"Class Lca": {
		"prefix": "Lca",
		"body": [
			"class Lca",
			"{",
			"public:",
			"",
			"    const std::vector<std::vector<int>>& e;",
			"",
			"    std::vector<int> depth, head, wson, size, fa;",
			"",
			"    explicit Lca(const std::vector<std::vector<int>>& __e, int root = 1)",
			"        : e(__e), depth(e.size()), head(e.size()), wson(e.size()), size(e.size()), fa(e.size(), root)",
			"    {",
			"        build(root);",
			"        build_head(root, root);",
			"    }",
			"",
			"    int operator()(int x, int y) const",
			"    {",
			"        while (head[x] != head[y])",
			"        {",
			"            if (depth[head[x]] > depth[head[y]])",
			"                x = fa[head[x]];",
			"            else",
			"                y = fa[head[y]];",
			"        }",
			"",
			"        if (depth[x] < depth[y])",
			"            return x;",
			"        else",
			"            return y;",
			"    }",
			"",
			"private:",
			"",
			"    void build(int p)",
			"    {",
			"        depth[p] = depth[fa[p]] + 1;",
			"        size[p] = 1;",
			"",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p])",
			"                continue;",
			"",
			"            fa[i] = p;",
			"",
			"            build(i);",
			"",
			"            size[p] += size[i];",
			"",
			"            if (size[i] > size[wson[p]])",
			"                wson[p] = i;",
			"        }",
			"    }",
			"",
			"    void build_head(int p, int top)",
			"    {",
			"        head[p] = top;",
			"",
			"        if (wson[p])",
			"            build_head(wson[p], top);",
			"        ",
			"        for (const auto& i : e[p])",
			"        {",
			"            if (i == fa[p] or i == wson[p])",
			"                continue;",
			"",
			"            build_head(i, i);",
			"        }",
			"    }",
			"",
			"};"
		],
		"description": "Class Lca"
	}
}